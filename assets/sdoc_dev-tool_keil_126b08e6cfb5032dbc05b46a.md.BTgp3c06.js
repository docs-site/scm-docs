import{_ as a,c as n,o as e,b0 as p}from"./chunks/framework.C5ev1SXp.js";const l="/scm-docs/assets/image451.DefVMXIf.jpeg",i="/scm-docs/assets/image-20230416150518915.B_6Vd8xe.png",t="/scm-docs/assets/image-20230416150619026.LtilnRx9.png",r="/scm-docs/assets/image-20230416150742032.Dx5JsMbm.png",c="/scm-docs/assets/image491.PS_12wtb.jpeg",o="/scm-docs/assets/image-20230416151336450.Dqw8rUZU.png",b="/scm-docs/assets/image511.C9qV5hyM.jpeg",d="data:image/png;base64,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",m="/scm-docs/assets/image-20230529223538076.C8mCbHbx.png",u="/scm-docs/assets/image-20230529223111082.CxXhSce2.png",R="/scm-docs/assets/image-20250924222342332.ChXvTQQt.png",A="/scm-docs/assets/image-20250924222720727.DjYxE8VV.png",h="/scm-docs/assets/image-20250924222831822.D_NoavZq.png",_=JSON.parse('{"title":"LV020-SCT分散加载文件","description":null,"frontmatter":{"title":"LV020-SCT分散加载文件","date":"2025-09-20T14:48:21.000Z","icon":"famicons:logo-markdown","permalink":"/sdoc/dev-tool/keil/126b08e6cfb5032dbc05b46a","index":true,"tags":null,"categories":null,"copyright":false,"keywords":null,"cover":null,"comments":null,"mathjax":null,"top":null,"description":null,"tdoc":{"detailDate":"2025-09-20T14:48:21.050Z","fulluuid":"dbc05b46abca47d8a176762f5148dc50","useduuid":"dbc05b46a"}},"headers":[],"relativePath":"sdoc/dev-tool/keil/126b08e6cfb5032dbc05b46a.md","filePath":"sdoc/01-开发工具/01-keil/LV020-SCT分散加载文件.md","lastUpdated":1758811394000}'),g={name:"sdoc/dev-tool/keil/126b08e6cfb5032dbc05b46a.md"};function M(x,s,v,I,S,q){return e(),n("div",null,[...s[0]||(s[0]=[p(`<h1 id="lv020-sct分散加载文件" tabindex="-1">LV020-SCT分散加载文件 <a class="header-anchor" href="#lv020-sct分散加载文件" aria-label="Permalink to &quot;LV020-SCT分散加载文件&quot;">​</a></h1><p>这里继续学习MDK的工程文件<code>*.sct</code>，使用的工程呢可以去这里下载：<a href="https://gitee.com/Embedfire-stm32f103-badao/ebf_stm32f103_badao_std_code" target="_blank" rel="noreferrer">ebf_stm32f103_badao_std_code: 野火STM32F103 霸道开发板 标准库教程配套代码 (gitee.com)</a></p><blockquote><p>链接: <a href="https://pan.baidu.com/s/1Uq_kTrjQWxPYFQ00HoxN1Q?pwd=gryg" target="_blank" rel="noreferrer">程序</a> 提取码: gryg</p></blockquote><h2 id="一、sct分散加载文件简介" tabindex="-1">一、sct分散加载文件简介 <a class="header-anchor" href="#一、sct分散加载文件简介" aria-label="Permalink to &quot;一、sct分散加载文件简介&quot;">​</a></h2><p>当工程按默认配置构建时，MDK会根据我们选择的芯片型号，获知芯片的内部FLASH及内部SRAM存储器概况，生成一个以工程名命名的后缀为*.sct的分散加载文件(Linker Control File，scatter loading)，<strong>链接器根据该文件的配置分配各个节区地址</strong>，生成分散加载代码，因此我们通过修改该文件可以定制具体节区的存储位置。例如，我们可以设置源文件中定义的所有变量自动按地址分配到外部SRAM，这样就不需要再使用关键字“__attribute__”按具体地址来指定了。</p><p>利用它还可以控制代码的加载区与执行区的位置，例如可以把程序代码存储到单位容量价格便宜的NAND-FLASH中，但在NAND-FLASH中的代码是不能像内部FLASH的代码那样直接提供给内核运行的，这时可通过修改分散加载文件，把代码加载区设定为NAND-FLASH的程序位置，而程序的执行区设定为SRAM中的位置，这样链接器就会生成一个配套的分散加载代码，该代码会把NAND-FLASH中的代码加载到SRAM中，内核再从SRAM中运行主体代码，大部分运行Linux系统的代码都是这样加载的。</p><h2 id="二、文件基本格式" tabindex="-1">二、文件基本格式 <a class="header-anchor" href="#二、文件基本格式" aria-label="Permalink to &quot;二、文件基本格式&quot;">​</a></h2><h3 id="_1-格式说明" tabindex="-1">1. 格式说明 <a class="header-anchor" href="#_1-格式说明" aria-label="Permalink to &quot;1. 格式说明&quot;">​</a></h3><p>下面先来看看MDK默认使用的sct文件，在Output目录下可找到“流水灯.sct”：</p><div class="language-txt vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">txt</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>// 默认的分散加载文件内容(“流水灯.sct”)</span></span>
<span class="line"><span>; *************************************************************</span></span>
<span class="line"><span>; *** Scatter-Loading Description File generated by uVision ***</span></span>
<span class="line"><span>; *************************************************************</span></span>
<span class="line"><span></span></span>
<span class="line"><span>LR_IROM1 0x08000000 0x00080000  {    ; load region size_region 加载域，基地址 空间大小</span></span>
<span class="line"><span>  ER_IROM1 0x08000000 0x00080000  {  ; load address = execution address 载地址 = 执行地址</span></span>
<span class="line"><span>   *.o (RESET, +First)</span></span>
<span class="line"><span>   *(InRoot$$Sections)</span></span>
<span class="line"><span>   .ANY (+RO)</span></span>
<span class="line"><span>   .ANY (+XO)</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>  RW_IRAM1 0x20000000 0x00010000  {  ; RW data 可读写数据</span></span>
<span class="line"><span>   .ANY (+RW +ZI)</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><p>在默认的sct文件配置中仅分配了Code、RO-data、RW-data及ZI-data这些大区域的地址，链接时各个节区(函数、变量等)直接根据属性排列到具体的地址空间。</p><p>sct文件中主要包含描述加载域及执行域的部分，一个文件中可包含有多个加载域，而一个加载域可由多个部分的执行域组成。同 等级的域之间使用花括号“{ }”分隔开，最外层的是加载域，第二层“{ }”内的是执行域，其整体结构如下：</p><img src="`+l+`" alt="分散加载文件的整体结构" style="zoom:67%;"><h3 id="_2-加载域" tabindex="-1">2. 加载域 <a class="header-anchor" href="#_2-加载域" aria-label="Permalink to &quot;2. 加载域&quot;">​</a></h3><p>sct文件的加载域格式如下：</p><div class="language-txt vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">txt</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>//方括号中的为选填内容</span></span>
<span class="line"><span>加载域名 (基地址 | (&quot;+&quot; 地址偏移)) [属性列表] [最大容量]</span></span>
<span class="line"><span>&quot;{&quot;</span></span>
<span class="line"><span>   执行区域描述+</span></span>
<span class="line"><span>&quot;}&quot;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>配合前面的分散加载文件内容，各部分介绍如下：</p><ul><li>加载域名：名称，在map文件中的描述会使用该名称来标识空间。如本例中只有一个加载域，该域名为LR_IROM1。</li><li>基地址+地址偏移：这部分说明了本加载域的基地址，可以使用+号连接一个地址偏移，算进基地址中， 整个加载域以它们的结果为基地址。如本例中的加载域基地址为0x08000000，刚好是STM32内部FLASH的基地址。</li><li>属性列表：属性列表说明了加载域的是否为绝对地址、N字节对齐等属性，该配置是可选的。本例中没有描述加载域的属性。</li><li>最大容量：最大容量说明了这个加载域可使用的最大空间，该配置也是可选的，如果加上这个配置后， 当链接器发现工程要分配到该区域的空间比容量还大，它会在工程构建过程给出提示。本例中的加载域最大容量为0x00080000，即512KB，正是本型号STM32内部FLASH的空间大小，比如我们要是定义一个全局变量，一下子超过了512KB，空间不足的时候，编译器就会报错。</li></ul><h3 id="_3-执行域" tabindex="-1">3. 执行域 <a class="header-anchor" href="#_3-执行域" aria-label="Permalink to &quot;3. 执行域&quot;">​</a></h3><p>sct文件的执行域格式：</p><div class="language-txt vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">txt</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>//方括号中的为选填内容</span></span>
<span class="line"><span>执行域名 (基地址 | &quot;+&quot; 地址偏移) [属性列表] [最大容量 ]</span></span>
<span class="line"><span>&quot;{&quot;</span></span>
<span class="line"><span>   输入节区描述</span></span>
<span class="line"><span>&quot;}&quot;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>执行域的格式与加载域是类似的，区别只是输入节区的描述有所不同，在上边流水灯.sct例子中包含了ER_IROM1及RW_IRAM两个执行域，它们分别对应描述了STM32的 内部FLASH及内部SRAM的基地址及空间大小。而它们内部的“输入节区描述”说明了哪些节区要存储到这些空间，链接器会根据它来处理编排这些节区。</p><h3 id="_4-输入节区描述" tabindex="-1">4. 输入节区描述 <a class="header-anchor" href="#_4-输入节区描述" aria-label="Permalink to &quot;4. 输入节区描述&quot;">​</a></h3><p>配合加载域及执行域的配置，在相应的域配置“输入节区描述”即可控制该节区存储到域中，其格式如下：</p><div class="language-txt vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">txt</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>//除模块选择样式部分外，其余部分都可选选填</span></span>
<span class="line"><span>模块选择样式&quot;(&quot;输入节区样式&quot;,&quot;&quot;+&quot;输入节区属性&quot;)&quot;</span></span>
<span class="line"><span>模块选择样式&quot;(&quot;输入节区样式&quot;,&quot;&quot;+&quot;节区特性&quot;)&quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>模块选择样式&quot;(&quot;输入符号样式&quot;,&quot;&quot;+&quot;节区特性&quot;)&quot;</span></span>
<span class="line"><span>模块选择样式&quot;(&quot;输入符号样式&quot;,&quot;&quot;+&quot;输入节区属性&quot;)&quot;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>配合前面流水灯.sct中的分散加载文件内容，各部分介绍如下：</p><ul><li><p>模块选择样式：模块选择样式可用于选择o及lib目标文件作为输入节区，它可以直接使用目标文件名或“*”通配符， 也可以使用“.ANY”。例如，使用语句“bsp_led.o”可以选择bsp_led.o文件，使用语句“*.o”可以选择所有o文件，使用“*.lib”可以选择所有lib文件，使用“*”或“.ANY”可以选择所有的o文件及lib文件。其中“.ANY”选择语句的优先级是最低的，所有其它选择语句选择完剩下的数据才会被“.ANY”语句选中。</p></li><li><p>输入节区样式：我们知道在目标文件中会包含多个节区或符号，通过输入节区样式可以选择要控制的节区。示例文件中“(RESET，+First)”语句的RESET就是输入节区样式，它选择了名为RESET的节区，并使用后面介绍的节区特性控制字“+First”表示它要存储到本区域的第一个地址。示例文件中的“*(InRoot$$Sections)”是一个链接器支持的特殊选择符号，它可以选择所有HAL库里要求存储到root区域的节区，如__main.o、__scatter*.o等内容。</p></li><li><p>输入符号样式：同样地，使用输入符号样式可以选择要控制的符号，符号样式需要使用“:gdef:”来修饰。 例如可以使用“*(:gdef:Value_Test)”来控制选择符号“Value_Test”。</p></li><li><p>输入节区属性：通过在模块选择样式后面加入输入节区属性，可以选择样式中不同的内容，每个节区属性描述符前要写一个“+”号， 使用空格或“，”号分隔开。可以使用的节区属性描述符如下：</p></li></ul><table tabindex="0"><thead><tr><th>节区属性描述符</th><th>说明</th></tr></thead><tbody><tr><td>RO-CODE及CODE</td><td>只读代码段</td></tr><tr><td>RO-DATA及CONST</td><td>只读数据段</td></tr><tr><td>RO及TEXT</td><td>包括RO-CODE及RO-DATA</td></tr><tr><td>RW-DATA</td><td>可读写数据段</td></tr><tr><td>RW-CODE</td><td>可读写代码段</td></tr><tr><td>RW及DATA</td><td>包括RW-DATA及RW-CODE</td></tr><tr><td>ZI及BSS</td><td>初始化为0的可读写数据段</td></tr><tr><td>XO</td><td>只可执行的区域</td></tr><tr><td>ENTRY</td><td>节区的入口点</td></tr></tbody></table><p>例如，示例文件中使用“.ANY(+RO)”选择剩余所有节区RO属性的内容都分配到执行域ER_IROM1中，使用“.ANY(+RW +ZI)”选择剩余所有节区RW及ZI属性的内容都分配到执行域RW_IRAM1中。</p><ul><li>节区特性：节区特性可以使用“+FIRST”或“+LAST”选项配置它要存储到的位置，FIRST存储到区域的头部，LAST存储到尾部。 通常重要的节区会放在头部，比如中断向量表，而CheckSum(校验和)之类的数据会放在尾部。例如流水灯.sct文件中使用“(RESET,+First)”选择了RESET节区，并要求把它放置到本区域第一个位置，而RESET是工程启动代码中定义的向量表，该向量表中定义的堆栈顶和复位向量指针必须要存储在内部FLASH的前两个地址，这样STM32才能正常启动，所以必须使用FIRST控制它们存储到首地址。</li></ul><div class="language-assembly vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">assembly</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>; Vector Table Mapped to Address 0 at Reset</span></span>
<span class="line"><span>                AREA    RESET, DATA, READONLY</span></span>
<span class="line"><span>                EXPORT  __Vectors</span></span>
<span class="line"><span>                EXPORT  __Vectors_End</span></span>
<span class="line"><span>                EXPORT  __Vectors_Size</span></span>
<span class="line"><span></span></span>
<span class="line"><span>__Vectors       DCD     __initial_sp               ; Top of Stack</span></span>
<span class="line"><span>                DCD     Reset_Handler              ; Reset Handler</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>总的来说，我们的sct示例文件配置如下：程序的加载域为内部FLASH的0x08000000，最大空间为0x00080000；程序的执行基地址与加载基地址相同，其中RESET节区定义的向量表要存储在内部FLASH的首地址，且所有o文件及lib文件的RO属性内容都存储在内部FLASH中；程序执行时RW及ZI区域都存储在以0x20000000为基地址，大小为0x00010000的空间(64KB)，这部分正好是STM32内部主SRAM的大小。</p><p>链接器根据sct文件链接，链接后各个节区、符号的具体地址信息可以在map文件中查看。需要注意，当有多个执行域的时候，STM32在分配变量的时候会优先选择容量较大的执行域进行分配，除非我们直接指定了某些文件必须在某个执行域。</p><h2 id="三、通过mdk配置选项来修改sct文件" tabindex="-1">三、通过MDK配置选项来修改sct文件 <a class="header-anchor" href="#三、通过mdk配置选项来修改sct文件" aria-label="Permalink to &quot;三、通过MDK配置选项来修改sct文件&quot;">​</a></h2><p>了解sct文件的格式后，可以手动编辑该文件控制整个工程的分散加载配置，但sct文件格式比较复杂，所以MDK提供了相应的配置选项可以方便地修改该文件，这些选项配置能满足基本的使用需求。</p><h3 id="_1-选择sct文件的产生方式" tabindex="-1">1. 选择sct文件的产生方式 <a class="header-anchor" href="#_1-选择sct文件的产生方式" aria-label="Permalink to &quot;1. 选择sct文件的产生方式&quot;">​</a></h3><p>首先需要选择sct文件产生的方式，选择使用MDK生成还是使用用户自定义的sct文件。在MDK的“【Options for Target】→【Linker】→【Use Memory Layout from Target Dialog】”选项即可配置该选择：</p><img src="`+i+'" alt="image-20230416150518915" style="zoom:50%;"><p>该选项为“是否使用Target对话框中的存储器分布配置”，勾选后，它会根据“Options for Target”对话框中的选项生成sct文件，这种情况下，即使我们手动打开它生成的sct文件编辑也是无效的，因为每次构建工程的时候，MDK都会生成新的sct文件覆盖旧文件。该选项在MDK中是默认勾选的，若希望MDK使用我们手动编辑的sct文件构建工程，需要取消勾选，并通过Scatter File框中指定sct文件的路径：</p><img src="'+t+'" alt="image-20230416150619026" style="zoom:50%;"><h3 id="_2-通过target对话框控制存储器分配" tabindex="-1">2. 通过Target对话框控制存储器分配 <a class="header-anchor" href="#_2-通过target对话框控制存储器分配" aria-label="Permalink to &quot;2. 通过Target对话框控制存储器分配&quot;">​</a></h3><p>若我们在Linker中勾选了“使用Target对话框的存储器布局”选项，那么“Options for Target”对话框中的存储器配置就生效了。主要配置是在Device标签页中选择芯片的类型，设定芯片基本的内部存储器信息以及在Target标签页中细化具体的 存储器配置(包括外部存储器)：</p><img src="'+r+'" alt="image-20230416150742032" style="zoom:50%;"><p>图中Device标签页中选定了芯片的型号为STM32F103ZE，选中后，在Target标签页中的存储器信息会根据芯片更新。</p><img src="'+c+'" alt="Target对话框中的存储器分配" style="zoom:67%;"><p>在Target标签页中存储器信息分成只读存储器(Read/Only Memory Areas)和可读写存储器(Read/Write Memory Areas)两类，即ROM和RAM，而且它们又细分成了片外存储器(off-chip)和片内存储器(on-chip)两类。</p><p>例如，由于我们已经选定了芯片的型号，MDK会自动根据芯片型号填充片内的ROM及RAM信息，其中的IROM1起始地址为0x80000000，大小为0x80000，正是该STM32型号的内部FLASH地址及大小；而IRAM1起始地址为0x20000000，大小为0x10000，正是该STM32内部主SRAM的地址及大小。图中的IROM1及IRAM1前面都打上了勾，表示这个配置信息会被采用，若取消勾选，则该存储配置信息是不会被使用的。</p><p>在某些芯片，会有多个内部SRAM空间，如STM32F429系列。它会在标签页中的IRAM2一栏默认也填写了配置信息，设置STM32F4系列特有的内部高速SRAM(被称为CCM)。</p><p>而如果希望设置外部SRAM空间，可以把外部SRAM的信息写到对话框里“off-chip”的“RAM1”配置中。</p><p>下面我们尝试修改Target标签页中的这些存储信息，例如，把STM32内部的SRAM分成两等份，按照下图中的配置，把IRAM1的基地址设置为0x20000000，大小改为0x8000，把IRAM2的基地址设置为0x20008000，大小为0x8000：</p><img src="'+o+`" alt="image-20230416151336450" style="zoom:50%;"><blockquote><p><a href="https://gitee.com/embedded-devs/scm-dev/tree/master/90-MDK%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B%E5%8F%8A%E6%96%87%E4%BB%B6%E5%85%A8%E8%A7%A3/01-SCT-demo/01-divided-internal-SRAM" target="_blank" rel="noreferrer">scm-dev: 90-MDK编译过程及文件全解/01-SCT-demo/01-divided-internal-SRAM</a></p></blockquote><p>然后编译工程， 查看到工程的sct文件如下所示：</p><div class="language-txt vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">txt</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>; *************************************************************</span></span>
<span class="line"><span>; *** Scatter-Loading Description File generated by uVision ***</span></span>
<span class="line"><span>; *************************************************************</span></span>
<span class="line"><span></span></span>
<span class="line"><span>LR_IROM1 0x08000000 0x00080000  {    ; load region size_region</span></span>
<span class="line"><span>  ER_IROM1 0x08000000 0x00080000  {  ; load address = execution address</span></span>
<span class="line"><span>   *.o (RESET, +First)</span></span>
<span class="line"><span>   *(InRoot$$Sections)</span></span>
<span class="line"><span>   .ANY (+RO)</span></span>
<span class="line"><span>   .ANY (+XO)</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>  RW_IRAM1 0x20000000 0x00008000  {  ; RW data</span></span>
<span class="line"><span>   .ANY (+RW +ZI)</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>  RW_IRAM2 0x20008000 0x00008000  {</span></span>
<span class="line"><span>   .ANY (+RW +ZI)</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><p>虽然修改后IRAM1和IRAM2加起来还是原来的内部SRAM空间，但它演示了对Target选项的修改是如何影响sct文件的，我们也可以尝试其它配置，观察sct文件，以学习sct文件的语法。可以发现，sct文件根据Target标签页做出了相应的改变，除了这种修改外，在Target标签页上还控制同时使用IRAM1和IRAM2、加入外部RAM(如外接的SRAM)，外部FLASH等。当RW_IRAM1空间用完后，会自动使用RW_IRAM2。</p><h3 id="_3-控制文件分配到指定的存储空间" tabindex="-1">3. 控制文件分配到指定的存储空间 <a class="header-anchor" href="#_3-控制文件分配到指定的存储空间" aria-label="Permalink to &quot;3. 控制文件分配到指定的存储空间&quot;">​</a></h3><blockquote><p><a href="https://gitee.com/embedded-devs/scm-dev/tree/master/90-MDK%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B%E5%8F%8A%E6%96%87%E4%BB%B6%E5%85%A8%E8%A7%A3/01-SCT-demo/02-config-file-memory" target="_blank" rel="noreferrer">scm-dev: 90-MDK编译过程及文件全解/01-SCT-demo/02-config-file-memory</a></p></blockquote><h4 id="_3-1-操作步骤" tabindex="-1">3.1 操作步骤 <a class="header-anchor" href="#_3-1-操作步骤" aria-label="Permalink to &quot;3.1 操作步骤&quot;">​</a></h4><p>设定好存储器的信息后，可以控制各个源文件定制到哪个部分存储器，在MDK的工程文件栏中，选中要配置的文件，右键，并在弹出的菜单中选择“Options for File xxxx”即可弹出一个文件配置对话框，在该对话框中进行存储器定制，如下图，使用右键打开文件配置并把它的RW区配置成使用IRAM2：</p><img src="`+b+`" alt="图 40‑52 使用右键打开文件配置并把它的RW区配置成使用IRAM2" style="zoom:67%;"><p>在弹出的对话框中有一个“Memory Assignment”区域(存储器分配)，在该区域中可以针对文件的各种属性内容进行分配，如Code/Const内容(RO)、Zero Initialized Data内容(ZI-data)以及Other Data内容(RW-data)，点击下拉菜单可以找到在前面<strong>Target页面配置的IROM1、IRAM1、IRAM2等存储器</strong>。例如图中我们把这个bsp_led.c文件的Other Data属性的内容分配到了IRAM2存储器(在Target标签页中我们勾选了IRAM1及IRAM2)，当在bsp_led.c文件定义了一些RW-data内容时(如初值非0的全局变量)， 该变量将会被分配到IRAM2空间，配置完成后点击OK，然后编译工程，查看到的sct文件内容如下：</p><div class="language-txt vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">txt</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>; *************************************************************</span></span>
<span class="line"><span>; *** Scatter-Loading Description File generated by uVision ***</span></span>
<span class="line"><span>; *************************************************************</span></span>
<span class="line"><span></span></span>
<span class="line"><span>LR_IROM1 0x08000000 0x00080000  {    ; load region size_region</span></span>
<span class="line"><span>  ER_IROM1 0x08000000 0x00080000  {  ; load address = execution address</span></span>
<span class="line"><span>   *.o (RESET, +First)</span></span>
<span class="line"><span>   *(InRoot$$Sections)</span></span>
<span class="line"><span>   .ANY (+RO)</span></span>
<span class="line"><span>   .ANY (+XO)</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>  RW_IRAM1 0x20000000 0x00008000  {  ; RW data</span></span>
<span class="line"><span>   .ANY (+RW +ZI)</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>  RW_IRAM2 0x20008000 0x00008000  {</span></span>
<span class="line"><span>    bsp_led.o (+RW)</span></span>
<span class="line"><span>   .ANY (+RW +ZI)</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div><p>可以看到在sct文件中的RW_IRAM2执行域中增加了一个选择bsp_led.o中RW内容的语句。类似地，我们还可以设置某些文件的代码段被存储到特定的ROM中，或者设置某些文件使用的ZI-data或RW-data存储到外部SRAM中(控制ZI-data到SDRAM时注意还需要修改启动文件设置堆栈对应的地址，原启动文件中的地址是指向内部SRAM的)。</p><p>虽然MDK的这些存储器配置选项很方便，但有很多高级的配置还是需要手动编写sct文件实现的，例如MDK选项中的内部ROM选项最多只可以填充两个选项位置，若想把内部ROM分成多片地址管理就无法实现了；另外MDK配置可控的最小粒度为文件，若想控制特定的节区也需要直接编辑sct文件。</p><p>不过这个并不能体现出我们定义的一些东西确实被分配到了RW_TRAM2。</p><p>【注意】这里我们要是修改了某一个c文件中数据在执行域的位置的话，会有这样的变化，文件左下角会有一个雪花的符号。</p><img src="`+d+'" alt="image-20230530093355921" style="zoom:80%;"><h4 id="_3-2-一个实例" tabindex="-1">3.2 一个实例 <a class="header-anchor" href="#_3-2-一个实例" aria-label="Permalink to &quot;3.2 一个实例&quot;">​</a></h4><ul><li>（1）前面我们通过MDK的Target面板修改sct文件如下：</li></ul><img src="'+m+`" alt="image-20230529223538076" style="zoom:50%;"><p>我们重新编译后，生成的sct文件内容如下：</p><div class="language-txt vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">txt</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>; *************************************************************</span></span>
<span class="line"><span>; *** Scatter-Loading Description File generated by uVision ***</span></span>
<span class="line"><span>; *************************************************************</span></span>
<span class="line"><span></span></span>
<span class="line"><span>LR_IROM1 0x08000000 0x00080000  {    ; load region size_region</span></span>
<span class="line"><span>  ER_IROM1 0x08000000 0x00080000  {  ; load address = execution address</span></span>
<span class="line"><span>   *.o (RESET, +First)</span></span>
<span class="line"><span>   *(InRoot$$Sections)</span></span>
<span class="line"><span>   .ANY (+RO)</span></span>
<span class="line"><span>   .ANY (+XO)</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>  RW_IRAM1 0x20000000 0x00008000  {  ; RW data</span></span>
<span class="line"><span>   .ANY (+RW +ZI)</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>  RW_IRAM2 0x20008000 0x00008000  {</span></span>
<span class="line"><span>    bsp_led.o (+RW)</span></span>
<span class="line"><span>   .ANY (+RW +ZI)</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div><ul><li>（2）我们在main.c中定一个全局数组，并在main.c中使用一下，防止被编译器优化</li></ul><img src="`+u+'" alt="image-20230529223111082" style="zoom:50%;"><ul><li>（3）我们编译一下，查看map文件中这个全局数组的地址（在Image Symbol Table部分）</li></ul><p><img src="'+R+`" alt="image-20250924222342332"></p><p>可以看到这个数组是存储在0x20008000这个位置的，也就是说这个变量被定义在了RW_IRAM2区域。</p><div class="language-txt vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">txt</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>  RW_IRAM2 0x20008000 0x00008000  {</span></span>
<span class="line"><span>    bsp_led.o (+RW)</span></span>
<span class="line"><span>   .ANY (+RW +ZI)</span></span>
<span class="line"><span>  }</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><ul><li>（4）通过【main.c】→【右键】→【Options for File main.c】→【OtherData】→【IRAM2 [0x20000000-0x20007FFF]】</li></ul><p><img src="`+A+`" alt="image-20250924222720727"></p><p>然后我们重新编译工程，生成的sct文件如下：</p><div class="language-txt vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">txt</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>; *************************************************************</span></span>
<span class="line"><span>; *** Scatter-Loading Description File generated by uVision ***</span></span>
<span class="line"><span>; *************************************************************</span></span>
<span class="line"><span></span></span>
<span class="line"><span>LR_IROM1 0x08000000 0x00080000  {    ; load region size_region</span></span>
<span class="line"><span>  ER_IROM1 0x08000000 0x00080000  {  ; load address = execution address</span></span>
<span class="line"><span>   *.o (RESET, +First)</span></span>
<span class="line"><span>   *(InRoot$$Sections)</span></span>
<span class="line"><span>   .ANY (+RO)</span></span>
<span class="line"><span>   .ANY (+XO)</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>  RW_IRAM1 0x20000000 0x00008000  {  ; RW data</span></span>
<span class="line"><span>    main.o (+RW)</span></span>
<span class="line"><span>   .ANY (+RW +ZI)</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>  RW_IRAM2 0x20008000 0x00008000  {</span></span>
<span class="line"><span>    bsp_led.o (+RW)</span></span>
<span class="line"><span>   .ANY (+RW +ZI)</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div></div><p>我们会发现RW_IRAM1多了一个 main.o (+RW)。</p><ul><li>（5）查看map文件，找到test数组的定义地址：</li></ul><p><img src="`+h+'" alt="image-20250924222831822"></p><p>我们发现，这个数组已经被定义到0x20000000为起始的区域中了。</p><blockquote><p>参考文档：</p><p><a href="https://doc.embedfire.com/mcu/stm32/f103badao/std/zh/latest/book/MDK.html" target="_blank" rel="noreferrer">46. MDK的编译过程及文件类型全解</a></p></blockquote>',87)])])}const C=a(g,[["render",M]]);export{_ as __pageData,C as default};
