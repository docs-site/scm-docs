import{_ as p,c as t,o as e,b0 as o}from"./chunks/framework.C5ev1SXp.js";const c="/scm-docs/assets/image-20220903160151362.C4tYBzPm.png",s="/scm-docs/assets/image-20220903162111744.B3DcRv2q.png",_=JSON.parse('{"title":"LV020-AT24C02实例分析","description":null,"frontmatter":{"title":"LV020-AT24C02实例分析","date":"2025-09-22T07:40:58.000Z","icon":"famicons:logo-markdown","permalink":"/sdoc/communication/i2c/126b09043fca31869028172d","index":true,"tags":null,"categories":null,"copyright":false,"keywords":null,"cover":null,"comments":null,"mathjax":null,"top":null,"description":null,"tdoc":{"detailDate":"2025-09-22T07:40:58.792Z","fulluuid":"69028172daa144dcbab34851329c3348","useduuid":"69028172d"}},"headers":[],"relativePath":"sdoc/communication/i2c/126b09043fca31869028172d.md","filePath":"sdoc/60-通信专题/01-I2C协议/LV020-AT24C02实例分析.md","lastUpdated":1758153691000}'),l={name:"sdoc/communication/i2c/126b09043fca31869028172d.md"};function i(n,a,r,d,m,C){return e(),t("div",null,[...a[0]||(a[0]=[o('<h1 id="lv020-at24c02实例分析" tabindex="-1">LV020-AT24C02实例分析 <a class="header-anchor" href="#lv020-at24c02实例分析" aria-label="Permalink to &quot;LV020-AT24C02实例分析&quot;">​</a></h1><p>AT24C02 是一个 256 (2K/8)个字节的 EEPROM ，它使用的接口就是 I2C ，在它的芯片手册中，给出了读写时序的时序图，我们就以此器件为例分析一下 I2C 的读写时序。</p><h2 id="一、单字节写时序" tabindex="-1">一、单字节写时序 <a class="header-anchor" href="#一、单字节写时序" aria-label="Permalink to &quot;一、单字节写时序&quot;">​</a></h2><img src="'+c+'" alt="image-20220903160151362" style="zoom:50%;"><p>（1）开始信号。</p><p>（2）发送 I2C 设备地址，每个 I2C 器件都有一个设备地址，通过发送具体的设备地址来决定访问哪个 I2C 器件。这是一个 8 位的数据，其中高 7 位是设备地址，最后 1 位是读写位，为 1 的话表示这是一个读操作，为 0 的话表示这是一个写操作。</p><p>（3） I2C 器件地址后面跟着一个读写位，为 0 表示写操作，为 1 表示读操作。</p><p>（4）从机发送的 ACK 应答信号。</p><p>（5）重新发送开始信号。</p><p>（6）发送要写写入数据的寄存器地址。</p><p>（7）从机发送的 ACK 应答信号。</p><p>（8）发送要写入寄存器的数据。</p><p>（9）从机发送的 ACK 应答信号。</p><p>（10）停止信号。</p><h2 id="二、单字节读时序" tabindex="-1">二、单字节读时序 <a class="header-anchor" href="#二、单字节读时序" aria-label="Permalink to &quot;二、单字节读时序&quot;">​</a></h2><img src="'+s+'" alt="image-20220903162111744" style="zoom:50%;"><p>I2C 单字节读时序比写时序要复杂一点，读时序分为 4 大步，第一步是发送设备地址，第二步是发送要读取的寄存器地址，第三步重新发送设备地址，最后一步就是 I2C 从器件输出要读取的寄存器值。</p><p>（1）主机发送起始信号。</p><p>（2）主机发送要读取的 I2C 从设备地址。</p><p>（3）读写控制位，因为是向 I2C 从设备发送数据，因此是写信号。</p><p>（4）从机发送的 ACK 应答信号。</p><p>（5）重新发送 START 信号。</p><p>（6）主机发送要读取的寄存器地址。</p><p>（7）从机发送的 ACK 应答信号。</p><p>（8）重新发送 START 信号。</p><p>（9）重新发送要读取的 I2C 从设备地址。</p><p>（10）读写控制位，这里是读信号，表示接下来是从 I2C 从设备里面读取数据。</p><p>（11）从机发送的 ACK 应答信号。</p><p>（12）从 I2C 器件里面读取到的数据。</p><p>（13）主机发出 NACK 信号，表示读取完成，不需要从机再发送 ACK 信号了。</p><p>（14）主机发出 STOP 信号，停止 I2C 通信。</p>',31)])])}const A=p(l,[["render",i]]);export{_ as __pageData,A as default};
