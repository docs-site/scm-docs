import{_ as a,c as n,o as e,b0 as p}from"./chunks/framework.C5ev1SXp.js";const i="/scm-docs/assets/image-20230529200721976.oXGxM2Pi.png",t="/scm-docs/assets/image-20230529205801781.RwnR8bfp.png",l="/scm-docs/assets/image-20230416143210100.BVUv__KN.png",o="/scm-docs/assets/image-20250923071936798.BApyfjb7.png",r="/scm-docs/assets/image-20250923072126127.B61MxNf0.png",c="/scm-docs/assets/image-20250923224112678.BULPob6N.png",m="/scm-docs/assets/image-20250923224320398.BM5RByng.png",d="/scm-docs/assets/image-20250923224611258.BcnwOvHc.png",b="/scm-docs/assets/image-20250923223237220.msvbmPya.png",g="/scm-docs/assets/image-20250923225237087.BPlLdHpq.png",_="/scm-docs/assets/image-20250923073208277.D4qZa74Z.png",u="/scm-docs/assets/image-2025092322541234567.Bdv3559p.png",h="/scm-docs/assets/image-2025092322561234567.DQ_Vspha.png",f="/scm-docs/assets/image-20250923225836902.B5Sf_UN1.png",x="/scm-docs/assets/image-20250923230303626.CLCDUCDp.png",R="/scm-docs/assets/image-20250923230544945.i7SbZegE.png",C="/scm-docs/assets/image-20250923230632097.BGJtlO-O.png",S="/scm-docs/assets/image-20250923230905497.Cf840zoU.png",P="/scm-docs/assets/image-20250923231435173.Bfxe18_w.png",O="/scm-docs/assets/image-20230529211803575.CuZZdQU6.png",k="/scm-docs/assets/image-20230529213119774.BVgBSZWR.png",E="/scm-docs/assets/image-20230529213416563.B05f3gcc.png",T="/scm-docs/assets/image-20230529210432888.CxMpnrZb.png",I="/scm-docs/assets/image-20230529210513865.Ck1fRZqR.png",y="/scm-docs/assets/image-20230529210631552.BOXxueEb.png",W=JSON.parse('{"title":"LV017-Listing目录文件","description":null,"frontmatter":{"title":"LV017-Listing目录文件","date":"2025-09-23T07:51:58.000Z","icon":"famicons:logo-markdown","permalink":"/sdoc/dev-tool/keil/126b0913865605b5493dc70e","index":true,"tags":null,"categories":null,"copyright":false,"keywords":null,"cover":null,"comments":null,"mathjax":null,"top":null,"description":null,"tdoc":{"detailDate":"2025-09-23T07:51:58.091Z","fulluuid":"5493dc70ee6849e0b32a91f39d8e2488","useduuid":"5493dc70e"}},"headers":[],"relativePath":"sdoc/dev-tool/keil/126b0913865605b5493dc70e.md","filePath":"sdoc/01-开发工具/01-keil/LV017-Listing目录文件.md","lastUpdated":1758153691000}'),L={name:"sdoc/dev-tool/keil/126b0913865605b5493dc70e.md"};function A(D,s,M,v,q,G){return e(),n("div",null,[...s[0]||(s[0]=[p('<h1 id="lv017-listing目录文件" tabindex="-1">LV017-Listing目录文件 <a class="header-anchor" href="#lv017-listing目录文件" aria-label="Permalink to &quot;LV017-Listing目录文件&quot;">​</a></h1><p>本篇笔记主要是参考的野火的文档。使用的工程呢可以去这里下载：<a href="https://gitee.com/Embedfire-stm32f103-badao/ebf_stm32f103_badao_std_code" target="_blank" rel="noreferrer">ebf_stm32f103_badao_std_code: 野火STM32F103 霸道开发板 标准库教程配套代码 (gitee.com)</a></p><blockquote><p>链接: <a href="https://pan.baidu.com/s/1Uq_kTrjQWxPYFQ00HoxN1Q?pwd=gryg" target="_blank" rel="noreferrer">程序</a> 提取码: gryg</p></blockquote><p>在Listing目录下包含了.map及.lst文件，它们都是文本格式的，可使用Windows的记事本软件打开。其中lst文件仅包含了一些汇编符号的链接信息，这些文件中<strong>重点是map文件</strong>。</p><h2 id="一、listing目录位置选择" tabindex="-1">一、Listing目录位置选择 <a class="header-anchor" href="#一、listing目录位置选择" aria-label="Permalink to &quot;一、Listing目录位置选择&quot;">​</a></h2><p>这里存放的都是链接器链接过程中用到的或者生成的文件，我们也是可以自行配置目录位置的：</p><img src="'+i+'" alt="image-20230529200721976" style="zoom:67%;"><p>【Options for Targe】→【Listing】→【SelectFolder for Listings】”选项配置这些文件的输出路径 。</p><h2 id="二、打开map文件" tabindex="-1">二、打开map文件 <a class="header-anchor" href="#二、打开map文件" aria-label="Permalink to &quot;二、打开map文件&quot;">​</a></h2><p>map文件存在于Listing目录中，我们怎么在MDK中打开？我们直接双击这里：</p><img src="'+t+`" alt="image-20230529205801781"><p>双击之后没打开？这个我也不清楚，但是重新配置一下listing目录的位置就可以双击打开啦，我也不是很明白为什么，可能是需要map文件在某个子目录吧。</p><h2 id="三、map文件说明" tabindex="-1">三、map文件说明 <a class="header-anchor" href="#三、map文件说明" aria-label="Permalink to &quot;三、map文件说明&quot;">​</a></h2><p>map文件是由链接器生成的，它主要包含交叉链接信息，查看该文件可以了解工程中各种符号之间的引用以及整个工程的Code、RO-data、RW-data以及ZI-data的详细及汇总信息。它的内容中主要包含了“节区的跨文件引用”、“删除无用节区”、“符号映像表”、“存储器映像索引”以及“映像组件大小”，接下来是各部分介绍。</p><h3 id="_1-节区的跨文件引用" tabindex="-1">1. 节区的跨文件引用 <a class="header-anchor" href="#_1-节区的跨文件引用" aria-label="Permalink to &quot;1. 节区的跨文件引用&quot;">​</a></h3><p>打开“流水灯.map”文件，可看到它的第一部分——节区的跨文件引用(<strong>Section Cross References</strong>)：</p><div class="language-txt vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">txt</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>// 节区的跨文件引用部分(流水灯.map文件)</span></span>
<span class="line"><span>Component: ARM Compiler 5.06 update 6 (build 750) Tool: armlink [4d35ed]</span></span>
<span class="line"><span></span></span>
<span class="line"><span>==============================================================================</span></span>
<span class="line"><span></span></span>
<span class="line"><span>Section Cross References</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    startup_stm32f10x_hd.o(RESET) refers to startup_stm32f10x_hd.o(STACK) for __initial_sp</span></span>
<span class="line"><span>    startup_stm32f10x_hd.o(RESET) refers to startup_stm32f10x_hd.o(.text) for Reset_Handler</span></span>
<span class="line"><span>    // 中间省略......</span></span>
<span class="line"><span>    startup_stm32f10x_hd.o(RESET) refers to stm32f10x_it.o(i.SysTick_Handler) for SysTick_Handler</span></span>
<span class="line"><span>    // 中间省略......</span></span>
<span class="line"><span>    main.o(i.main) refers to bsp_led.o(i.LED_GPIO_Config) for LED_GPIO_Config</span></span>
<span class="line"><span>    main.o(i.main) refers to main.o(i.Delay) for Delay</span></span>
<span class="line"><span>    bsp_led.o(i.LED_GPIO_Config) refers to stm32f10x_rcc.o(i.RCC_APB2PeriphClockCmd) for RCC_APB2PeriphClockCmd</span></span>
<span class="line"><span>    bsp_led.o(i.LED_GPIO_Config) refers to stm32f10x_gpio.o(i.GPIO_Init) for GPIO_Init</span></span>
<span class="line"><span>    bsp_led.o(i.LED_GPIO_Config) refers to stm32f10x_gpio.o(i.GPIO_SetBits) for GPIO_SetBits</span></span>
<span class="line"><span>    // 后边省略......</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><p>在这部分中，详细列出了各个.o文件之间的符号引用。由于.o文件是由asm或c/c++源文件编译后生成的，各个文件及文件内的节区间互相独立，链接器根据它们之间的互相引用链接起来，链接的详细信息在这个“Section Cross References”一一列出。</p><p>例如，开头部分说明的是startup_stm32f10x.o文件中的“RESET”节区为它使用的“__initial_sp” 符号引用了同文件“STACK”节区。</p><p>我们继续浏览，可看到main.o文件的引用说明，如说明main.o文件的i.main节区为它使用的 LED_GPIO_Config 符号引用了 bsp_led.o 文件 i.LED_GPIO_Config 节区。</p><p>同样地，下面还有bsp_led.o文件的引用说明，如说明了bsp_led.o文件的i.LED_GPIO_Config节区为它使用的GPIO_Init符号引用了stm32f10x_gpio.o文件的i.GPIO_Init节区。</p><p>可以了解到，这些跨文件引用的符号其实就是源文件中的函数名、变量名。有时在构建工程的时候，编译器会输出 “Undefined symbol xxx (referred from xxx.o)” 这样的提示，该提示的原因就是在链接过程中，某个文件无法在外部找到它引用的标号，因而产生链接错误。例如，我们把bsp_led.c文件中定义的函数LED_GPIO_Config改名为LED_GPIO_ConfigA，而不修改main.c文件中的调用，就会出现main文件无法找到LED_GPIO_Config符号的提示（Undefined symbol xxxx from xxx.o）。</p><img src="`+l+`" alt="image-20230416143210100"><h3 id="_2-删除无用节区" tabindex="-1">2. 删除无用节区 <a class="header-anchor" href="#_2-删除无用节区" aria-label="Permalink to &quot;2. 删除无用节区&quot;">​</a></h3><p>map文件的第二部分是删除无用节区的说明(<strong>Removing Unused input sections from the image</strong>)：</p><div class="language-txt vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">txt</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>//删除无用节区部分(流水灯.map文件)</span></span>
<span class="line"><span>Removing Unused input sections from the image.</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    Removing startup_stm32f10x_hd.o(HEAP), (512 bytes).</span></span>
<span class="line"><span>    Removing core_cm3.o(.emb_text), (32 bytes).</span></span>
<span class="line"><span>    Removing system_stm32f10x.o(i.SystemCoreClockUpdate), (164 bytes).</span></span>
<span class="line"><span>    Removing system_stm32f10x.o(.data), (20 bytes).</span></span>
<span class="line"><span>    Removing misc.o(i.NVIC_Init), (112 bytes).</span></span>
<span class="line"><span>    Removing misc.o(i.NVIC_PriorityGroupConfig), (20 bytes).</span></span>
<span class="line"><span>    Removing misc.o(i.NVIC_SetVectorTable), (20 bytes).</span></span>
<span class="line"><span>    // 后边的省略</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>这部分列出了在链接过程它发现工程中未被引用的节区，这些未被引用的节区将会被删除(指不加入到.axf文件，不是指在.o文件删除)，这样可以防止这些无用数据占用程序空间。</p><p>例如，上面的信息中说明startup_stm32f10x.o中的HEAP(在启动文件中定义的用于动态分配的“堆”区)以及 stm32f10x_adc.o的各个节区都被删除了，因为在我们这个工程中没有使用动态内存分配，也没有引用任何stm32f10x_adc.c中的内容。由此也可以知道，虽然我们把STM32HAL库的各个外设对应的c库文件都添加到了工程，但不必担心这会使工程变得臃肿，因为未被引用的节区内容不会被加入到最终的机器码文件中。</p><p>删除函数功能在MDK的配置中可以设置，勾选以后删除得多，不勾选删除得少，如下图：</p><img src="`+o+'" alt="image-20250923071936798" style="zoom:50%;"><p>在map文件Removing Unused input sections from the image的最下面还会有删除的冗余函数的大小：</p><img src="'+r+'" alt="image-20250923072126127" style="zoom:50%;"><h3 id="_3-符号映像表" tabindex="-1">3. 符号映像表 <a class="header-anchor" href="#_3-符号映像表" aria-label="Permalink to &quot;3. 符号映像表&quot;">​</a></h3><p>map文件的第三部分是符号映像表(<strong>Image Symbol Table</strong>)：</p><p><img src="'+c+'" alt="image-20250923224112678"></p><h4 id="_3-1-local-symbols" tabindex="-1">3.1 Local Symbols <a class="header-anchor" href="#_3-1-local-symbols" aria-label="Permalink to &quot;3.1 Local Symbols&quot;">​</a></h4><p>包括局部标号，用Static声明的全局变量地址和大小，C文件中函数的地址和用static声明的函数代码大小，汇编文件中的标号地址（作用域限本文件）等。</p><h5 id="_3-1-1-reset" tabindex="-1">3.1.1 RESET <a class="header-anchor" href="#_3-1-1-reset" aria-label="Permalink to &quot;3.1.1 RESET&quot;">​</a></h5><p>我们可以看到上面的RESET：</p><p><img src="'+m+'" alt="image-20250923224320398"></p><p>地址在0x0800 0000，占用了304字节，它定义在startup_stm32f10x_hd.s（STM32F103ZET6）中：</p><p><img src="'+d+'" alt="image-20250923224611258"></p><blockquote><p><strong>AREA</strong>：定义代码或数据段的伪指令。</p><p><strong>RESET</strong>：段名称，通常用于标识复位向量段（程序启动时执行的第一段代码）。</p><p><strong>DATA</strong>：段类型属性，表示该段包含数据（而不是代码）。</p><p><strong>READONLY</strong>：段属性，表示该段是只读的。</p></blockquote><p>RESET标识复位向量表区域，用于告诉链接器这个段包含<strong>中断向量表</strong>。在系统启动时，硬件会自动从这个区域读取初始配置。</p><h5 id="_3-1-2-i-led-gpio-config" tabindex="-1">3.1.2 i.LED_GPIO_Config <a class="header-anchor" href="#_3-1-2-i-led-gpio-config" aria-label="Permalink to &quot;3.1.2 i.LED_GPIO_Config&quot;">​</a></h5><p>接下来看这个 i.LED_GPIO_Config ：</p><p><img src="'+b+'" alt="image-20250923223237220"></p><p>这个表列出了被引用的各个符号在存储器中的具体地址、占据的空间大小等信息。如我们可以查到LED_GPIO_Config符号存储在0x080002c8地址，它属于Thumb Code类型，大小为90字节，它所在的节区为bsp_led.o文件的i.LED_GPIO_Config节区。</p><h5 id="_3-1-3-static修饰的函数" tabindex="-1">3.1.3 static修饰的函数 <a class="header-anchor" href="#_3-1-3-static修饰的函数" aria-label="Permalink to &quot;3.1.3 static修饰的函数&quot;">​</a></h5><p>还有这种 i.xx 后面跟了一个 xx 函数：</p><p><img src="'+g+'" alt="image-20250923225237087"></p><p>这个表示在源文件中这个函数使用了static修饰：</p><img src="'+_+'" alt="image-20250923073208277" style="zoom:50%;"><h5 id="_3-1-4-sram区" tabindex="-1">3.1.4 SRAM区 <a class="header-anchor" href="#_3-1-4-sram区" aria-label="Permalink to &quot;3.1.4 SRAM区&quot;">​</a></h5><p>其实这里应该还会有SRAM区，但是我用的这个工程好像没有，网上参考其他教程分析一下：</p><img src="'+u+'" alt="在这里插入图片描述" style="zoom:80%;"><p>我们继续看到后面的.bss段，包括了 HEAP 和 STACK区域：</p><p><img src="'+h+'" alt="在这里插入图片描述"></p><p>上图中我们可以看到 HEAP 的起始地址为 0x20002338，ram从 0x2000 0000开始存放的依次为 .data、.bss、HEAP、STACK。</p><p>HEAP在 startup_stm32fxxx.s 中定义过大小为 0x200，所以结束地址为0x20002538， HEAP 是和 STACK连接在一起的，所以STACK的起始地址为 0x20002538，大小 0X400，结束地址为 0x20002938。最后我们可以看到 __initial_sp 指向的是 0x20002938，入栈从高地址开始入栈，地址越来越小。</p><img src="'+f+'" alt="image-20250923225836902" style="zoom:50%;"><h4 id="_3-2-global-symbols" tabindex="-1">3.2 Global Symbols <a class="header-anchor" href="#_3-2-global-symbols" aria-label="Permalink to &quot;3.2 Global Symbols&quot;">​</a></h4><p>全局标号，全局变量的地址和大小，C文件中函数的地址及其代码大小，汇编文件中的标号地址（作用域全工程）等。</p><p><img src="'+x+'" alt="image-20250923230303626"></p><p>我们找到Flash地址开始的部分：</p><p><img src="'+R+'" alt="image-20250923230544945"></p><p>在 startup_stm32fxxx.s 能看到对应的部分：</p><img src="'+C+'" alt="image-20250923230632097" style="zoom:50%;"><p>看到最后的 RAM区，注意下图中标出的两行的功能：</p><p><img src="'+S+'" alt="image-20250923230905497"></p><h3 id="_4-存储器映像索引" tabindex="-1">4. 存储器映像索引 <a class="header-anchor" href="#_4-存储器映像索引" aria-label="Permalink to &quot;4. 存储器映像索引&quot;">​</a></h3><p>map文件的第四部分是存储器映像索引(<strong>Memory Map of the image</strong>)：</p><p><img src="'+P+'" alt="image-20250923231435173"></p><p>工程的存储器映像索引分为 ER_IROM1 及 RW_IRAM1 部分，它们分别对应STM32内部FLASH及SRAM的空间。相对于符号映像表，这个索引表描述的单位是节区，而且它描述的主要信息中包含了节区的类型及属性，由此可以区分Code、RO-data、RW-data及ZI-data。</p><ul><li>（1）加载域和执行域</li></ul><p>我们先来看一下这两个部分：</p><img src="'+O+'" alt="image-20230529211803575"><p>框中圈出来的，翻译过来就是加载区域和执行区域，加载区域基地址是0x08000000，最大大小为0x0008000，换算一下就是512KB，这就是我们整个内部FLASH，执行区域的基地址为0x08000000，最大也是0x0008000，中间的Size就是两者实际的大小，这两个一般是不一样大的，一般来讲，执行区域的大小是要小于加载区域的大小的，因为RW section在运行的时候会被复制到内部SRAM中去，比如说全局变量就属于这一部分，我们可以定义一个较大的数组,，然后在main.c中更改一下其中的数据然后重新编译，应该就会发现执行区域和加载区域大小发生了变化，我们定义一个大小为10字节的全局数组：</p><img src="'+k+'" alt="image-20230529213119774"><p>然后我们用执行域大小减去加载域大小，会发现值为0xc，其实已经不仅仅是10字节了，这里就是12个字节，具体还有什么就触及知识盲区了，后边知道了再补充吧。但是我们发现在MDK输出信息窗口的RW-data的大小为12字节，其实这里<strong>执行域大小-加载域大小应该就是等于RW-data</strong>的大小，因为这一部分会被复制到SRAM运行。</p><img src="'+E+'" alt="image-20230529213416563"><ul><li>（2）最后两部分</li></ul><p>例如，从上面的表中我们可以看到i.LED_GPIO_Config节区存储在内部FLASH的0x080002c4地址，大小为0x00000060，类型为Code，属性为RO。</p><img src="'+T+'" alt="image-20230529210432888"><p>而程序的STACK节区(栈空间)存储在SRAM的0x20000000地址，大小为0x00000400，类型为Zero，属性为RW（即RW-data）:</p><img src="'+I+`" alt="image-20230529210513865"><h3 id="_5-映像组件大小" tabindex="-1">5. 映像组件大小 <a class="header-anchor" href="#_5-映像组件大小" aria-label="Permalink to &quot;5. 映像组件大小&quot;">​</a></h3><p>map文件的最后一部分是包含映像组件大小的信息(<strong>Image component sizes</strong>)，这也是最常查询的内容：</p><div class="language-txt vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">txt</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>// 映像组件大小部分(流水灯.map文件)</span></span>
<span class="line"><span>Image component sizes</span></span>
<span class="line"><span></span></span>
<span class="line"><span>      Code (inc. data)   RO Data    RW Data    ZI Data      Debug   Object Name</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        96          6          0          0          0        658   bsp_led.o</span></span>
<span class="line"><span>         0          0          0          0          0       4524   core_cm3.o</span></span>
<span class="line"><span>       278          8          0          0          0       1779   main.o</span></span>
<span class="line"><span>        36          8        304          0       1024        972   startup_stm32f10x_hd.o</span></span>
<span class="line"><span>       282          0          0          0          0       2887   stm32f10x_gpio.o</span></span>
<span class="line"><span>        26          0          0          0          0       5038   stm32f10x_it.o</span></span>
<span class="line"><span>        32          6          0          0          0        701   stm32f10x_rcc.o</span></span>
<span class="line"><span>       328         28          0          0          0     214261   system_stm32f10x.o</span></span>
<span class="line"><span>    ----------------------------------------------------------------------</span></span>
<span class="line"><span>      1084         56        320          0       1024     230820   Object Totals</span></span>
<span class="line"><span>         0          0         16          0          0          0   (incl. Generated)</span></span>
<span class="line"><span>         6          0          0          0          0          0   (incl. Padding)</span></span>
<span class="line"><span>// 中间部分省略</span></span>
<span class="line"><span>==============================================================================</span></span>
<span class="line"><span>      Code (inc. data)   RO Data    RW Data    ZI Data      Debug   </span></span>
<span class="line"><span></span></span>
<span class="line"><span>      1172         72        320          0       1024     230312   Grand Totals</span></span>
<span class="line"><span>      1172         72        320          0       1024     230312   ELF Image Totals</span></span>
<span class="line"><span>      1172         72        320          0          0          0   ROM Totals</span></span>
<span class="line"><span>==============================================================================</span></span>
<span class="line"><span>    Total RO  Size (Code + RO Data)                 1492 (   1.46kB)</span></span>
<span class="line"><span>    Total RW  Size (RW Data + ZI Data)              1024 (   1.00kB)</span></span>
<span class="line"><span>    Total ROM Size (Code + RO Data + RW Data)       1492 (   1.46kB)</span></span>
<span class="line"><span>==============================================================================</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br></div></div><p>这部分包含了各个使用到的.o文件的空间汇总信息、整个工程的空间汇总信息以及占用不同类型存储器的空间汇总信息，它们分类描述了具体占据的Code、RO-data、RW-data及ZI-data的大小，并根据这些大小统计出占据的ROM总空间。我们仅来看一看分析<strong>最后两部分</strong>信息：</p><img src="`+y+'" alt="image-20230529210631552" style="zoom:45%;"><p>如Grand Totals一项，它表示整个代码占据的所有空间信息，其中Code类型的数据大小为1172字节，这部分包含了72字节的指令数据(inc .data)已算在内，另外RO-data占320字节，RW-data占0字节，ZI-data占1024字节。在它的下面两行有一项ROM Totals信息，它列出了各个段所占据的ROM空间，除了ZI-data不占ROM空间外，其余项都与Grand Totals中相等(RW-data也占据ROM空间，只是本工程中没有RW-data类型的数据而已)。</p><p>ELF ImageTotals：可执行链接格式映像文件大小。</p><p>ROM Totals：包含映像所需要的ROM的最小大小，这不包括ZI和在ROM中的调试信息。</p><p>最后一部分列出了只读数据(RO)、可读写数据(RW)及占据的ROM大小。其中只读数据大小为1492字节，它包含Code段及RO-data段; 可读写数据大小为1024字节，它包含RW-data及ZI-data段；占据的ROM大小为1492字节，它除了Code段和RO-data段，还包含了运行时需要从ROM加载到RAM的RW-data数据（本工程中RW-data数据为0字节）。</p><h3 id="_6-总结" tabindex="-1">6. 总结 <a class="header-anchor" href="#_6-总结" aria-label="Permalink to &quot;6. 总结&quot;">​</a></h3><p>综合整个map文件的信息，可以分析出，当程序下载到STM32的内部FLASH时，需要使用的内部FLASH是从0x0800 0000地址开始的大小为1492字节的空间；当程序运行时，需要使用的内部SRAM是从0x20000000地址开始的大小为1024字节的空间。</p><p>粗略一看，发现这个小程序竟然需要1024字节的SRAM，但仔细分析map文件后，可了解到这1024字节都是STACK节区的空间(即栈空间)，栈空间大小是在启动文件中定义的，这1024字节是默认值(0x00000400)。它是提供给C语言程序局部变量申请使用的空间，若我们确认自己的应用程序不需要这么大的栈，完全可以修改启动文件，把它改小一点，查看前面讲解的htm静态调用图文件可了解静态的栈调用情况，可以用它作为参考。</p><blockquote><p>参考资料：</p><p><a href="https://bbs.huaweicloud.com/blogs/375342" target="_blank" rel="noreferrer">STM32的内存管理相关（内存架构，内存管理，map文件分析）-云社区-华为云</a></p><p><a href="https://doc.embedfire.com/mcu/stm32/f103badao/std/zh/latest/book/MDK.html" target="_blank" rel="noreferrer">46. MDK的编译过程及文件类型全解</a></p></blockquote>',99)])])}const Z=a(L,[["render",A]]);export{W as __pageData,Z as default};
