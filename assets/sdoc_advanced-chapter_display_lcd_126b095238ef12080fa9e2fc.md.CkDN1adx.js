import{_ as e,c as a,o as r,b0 as l}from"./chunks/framework.C5ev1SXp.js";const s="/scm-docs/assets/image-20230519211819014.B5isFgoY.png",n="/scm-docs/assets/image-20230519212447766.C46NHh3v.png",i="/scm-docs/assets/image-20230519214635944.DjQl3GC9.png",d="/scm-docs/assets/image-20230519225138990.BuS8Hb8w.png",c="/scm-docs/assets/image-20230519215250956.CcSMY9FC.png",o="/scm-docs/assets/image-20230519215852281.BkaFs6FJ.png",g="/scm-docs/assets/image-20230519220200874.ChGqDxFf.png",h="/scm-docs/assets/image-20230519225401282.Bh2MW-IO.png",m="/scm-docs/assets/image-20230519225604394.BzVISvar.png",y="/scm-docs/assets/image-20230519225636754.DmwvZEF6.png",x="/scm-docs/assets/image-20230519225718890.mENMFPPX.png",p="/scm-docs/assets/image-20230519225754328.NiUP43X9.png",_="/scm-docs/assets/image-20230519225832833.DBKuuoiT.png",D="/scm-docs/assets/image-20230523221724206.BVOUB-O5.png",M="/scm-docs/assets/image-20230523222310976.dPdcapbd.png",E="/scm-docs/assets/image-20230524123443366.CzXicCd7.png",C="/scm-docs/assets/image-20230524124345341.BDbU8r2h.png",b="/scm-docs/assets/image-20230523223202157.DpdlN8Gj.png",L="/scm-docs/assets/image-20230523224446808.zsFZAurB.png",f="/scm-docs/assets/image-20230523223509624.CM0US8am.png",I="/scm-docs/assets/image-20230524130422020.6M_hsZ2y.png",B="/scm-docs/assets/image-20230523224720981.BKqGLoS4.png",u="/scm-docs/assets/image-20230523223647692.BacFDuGT.png",R="/scm-docs/assets/image-20230523223825411.gjcgEGMH.png",A="/scm-docs/assets/image-20230523223947867.BbesKrBH.png",G="/scm-docs/assets/image-20230523224100259.RLSs8C33.png",S="/scm-docs/assets/image-20230523224159218.DC72l0eE.png",q="/scm-docs/assets/image-20230523224301780.UIDQxlkB.png",P="/scm-docs/assets/image-20230524133046886.BIZBs0yY.png",k="/scm-docs/assets/image-20230524133125714.CyPiBxe7.png",F="/scm-docs/assets/image-20230524133202987.DbpjcKQw.png",X="/scm-docs/assets/image-20230524215000828.BSSk9S_k.png",Y="/scm-docs/assets/image-20230524215142332.P-DfRFrZ.png",z="/scm-docs/assets/image-20230524215313557.DsBDE9-L.png",T="/scm-docs/assets/image-20230524215421446.CTQig-GL.png",U="/scm-docs/assets/image-20230524215619493.B7sEqRzN.png",H=JSON.parse('{"title":"LV016-IL9341简介","description":null,"frontmatter":{"title":"LV016-IL9341简介","date":"2025-09-27T18:41:11.000Z","icon":"famicons:logo-markdown","permalink":"/sdoc/advanced-chapter/display/lcd/126b095238ef12080fa9e2fc","index":true,"tags":null,"categories":null,"copyright":false,"keywords":null,"cover":null,"comments":null,"mathjax":null,"top":null,"description":null,"tdoc":{"detailDate":"2025-09-27T18:41:11.288Z","fulluuid":"80fa9e2fc1c846ac9bfafe695ffc6b7d","useduuid":"80fa9e2fc"}},"headers":[],"relativePath":"sdoc/advanced-chapter/display/lcd/126b095238ef12080fa9e2fc.md","filePath":"sdoc/30-进阶篇/04-显示屏/02-LCD/LV016-IL9341简介.md","lastUpdated":1758811394000}'),V={name:"sdoc/advanced-chapter/display/lcd/126b095238ef12080fa9e2fc.md"};function w(v,t,N,W,O,Z){return r(),a("div",null,[...t[0]||(t[0]=[l('<h1 id="lv016-il9341简介" tabindex="-1">LV016-IL9341简介 <a class="header-anchor" href="#lv016-il9341简介" aria-label="Permalink to &quot;LV016-IL9341简介&quot;">​</a></h1><h2 id="一、简介" tabindex="-1">一、简介 <a class="header-anchor" href="#一、简介" aria-label="Permalink to &quot;一、简介&quot;">​</a></h2><p>ILI9341是<a href="http://www.ilitek.com/index.aspx" target="_blank" rel="noreferrer">奕力科技股份有限公司 (ilitek.com)</a>的一款小尺寸驱动IC，我在官网没看到芯片手册，但是有些查datasheet的地方是可以查到的，这里就不写链接了。我在本地保存了一份：<a href="https://gitee.com/docs-site/scm-reference-guide/raw/master/10-%E6%98%BE%E7%A4%BA%E5%B1%8F%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/TFTLCD%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/01ILI9341_DS.pdf" target="_blank" rel="noreferrer">01ILI9341_DS.pdf</a></p><p>它是一个支持分辨率为240x320点阵的a-TFT LCD 的262144（26万色）色单片驱动器。这个单片驱动器包含了一个720通道的源极驱动器（source driver)，一个320通道的栅极驱动器（gate driver），自带一个172800字节（320x240x18/8）的GRAM用于显示240x320分辨率的图片数据。ILI9341提供8位/9位/16位/18位的并行MCU数据总线，6位/16位/18位RGB接口数据总线以及3或4线SPI接口（serial peripheral interface），工作于1.65V-3.3V。</p><h2 id="二、内部框图" tabindex="-1">二、内部框图 <a class="header-anchor" href="#二、内部框图" aria-label="Permalink to &quot;二、内部框图&quot;">​</a></h2><p>我们可以查看<a href="https://gitee.com/docs-site/scm-reference-guide/raw/master/10-%E6%98%BE%E7%A4%BA%E5%B1%8F%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/TFTLCD%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/01ILI9341_DS.pdf" target="_blank" rel="noreferrer">01ILI9341_DS.pdf</a>的3. Block Diagram :</p><img src="'+s+'" alt="image-20230519211819014" style="zoom:50%;"><h3 id="_1-1-控制和信号引脚" tabindex="-1">1. ① 控制和信号引脚 <a class="header-anchor" href="#_1-1-控制和信号引脚" aria-label="Permalink to &quot;1. ① 控制和信号引脚&quot;">​</a></h3><p>①为控制引脚和信号引脚，支持DBI B类接口（ Intel 8080接口）、 DPI接口、 MIPI DSI接口输入。我们可以根据其不同状态设置可以使芯片工作在不同的模式，如每个像素点的位数是6、16还是18位；可配置使用SPI接口、8080接口还是RGB接口与MCU进行通讯。</p><p>MCU可以通过SPI、8080接口或RGB接口与ILI9341进行通讯，从而访问它的控制寄存器(CR)、地址计数器(AC)、及GRAM。经过索引寄存器（ IR）、 控制寄存器（ CR）、地址寄存器（ AC）、读数据寄存器（ RDR）、写数据寄存器（ WDR）到GRAM。最后， GRAM把显示内容传输到LCD屏幕的显示。</p><p>控制引脚IM[2:0]用于设置控制器的接口模式，如下表所示（<a href="https://gitee.com/docs-site/scm-reference-guide/raw/master/10-%E6%98%BE%E7%A4%BA%E5%B1%8F%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/TFTLCD%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/01ILI9341_DS.pdf" target="_blank" rel="noreferrer">01ILI9341_DS.pdf</a>的6. Block Function Description ）。 我使用的这个显示屏支持的接口为16 Bit的MIPI-DBIB类，也就是8080接口，使用16根数据线，支持RGB565格式，因此IM[2:0]值为001，该值由屏幕供应商生产时硬件设置，此时用到的数据引脚为DB[15:0]。</p><img src="'+n+'" alt="image-20230519212447766" style="zoom:50%;"><h3 id="_2-2-gram" tabindex="-1">2. ② GRAM <a class="header-anchor" href="#_2-2-gram" aria-label="Permalink to &quot;2. ② GRAM&quot;">​</a></h3><p>该芯片最主核心部分是位于中间的GRAM(Graphics RAM)，它就是显存。GRAM中每个存储单元都对应着液晶面板的一个像素点。它右侧的各种模块共同作用把GRAM存储单元的数据转化成液晶面板的控制信号，使像素点呈现特定的颜色，而像素点组合起来则成为一幅完整的图像。</p><h3 id="_3-3-led控制器" tabindex="-1">3. ③ LED控制器 <a class="header-anchor" href="#_3-3-led控制器" aria-label="Permalink to &quot;3. ③ LED控制器&quot;">​</a></h3><p>在GRAM的左侧还有一个 ③ LED控制器(LED Controller)。LCD为非发光性的显示装置，它需要借助背光源才能达到显示功能，LED控制器就是用来控制液晶屏中的LED背光源。</p><h2 id="三、与stm32引脚对应关系" tabindex="-1">三、与STM32引脚对应关系 <a class="header-anchor" href="#三、与stm32引脚对应关系" aria-label="Permalink to &quot;三、与STM32引脚对应关系&quot;">​</a></h2><p>这些引出的信号线即8080通讯接口，带 X 的表示低电平有效，STM32通过该接口与ILI9341芯片进行通讯，实现对液晶屏的控制。通讯的内容主要包括命令和显存数据，显存数据即各个像素点的RGB565内容；命令是指对ILI9341的控制指令，MCU可通过8080接口发送命令编码控制ILI9341的工作方式，例如复位指令、设置光标指令、睡眠模式指令等等，具体的指令在<a href="https://gitee.com/docs-site/scm-reference-guide/raw/master/10-%E6%98%BE%E7%A4%BA%E5%B1%8F%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/TFTLCD%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/01ILI9341_DS.pdf" target="_blank" rel="noreferrer">01ILI9341_DS.pdf</a> 数据手册均有详细说明。</p><img src="'+i+'" alt="image-20230519214635944" style="zoom:50%;"><p>我们这一节笔记用到的信号线如下表（注意我使用的模块只引出了DB[15:0]使用）：</p><table tabindex="0"><thead><tr><th>信号线</th><th style="text-align:left;">ILI9341对应的信号线</th><th style="text-align:left;">说明</th></tr></thead><tbody><tr><td>LCD_DB[17:1]</td><td style="text-align:left;">D[15:0]</td><td style="text-align:left;">16位双向数据线</td></tr><tr><td>LCD_RD</td><td style="text-align:left;">RDX</td><td style="text-align:left;">LCD读数据信号，低电平有效</td></tr><tr><td>LCD_RS</td><td style="text-align:left;">D/CX</td><td style="text-align:left;">数据/命令信号，高电平时，D[15:0]表示的是数据(RGB像素数据或命令数据)，低电平时D[15:0]表示控制命令</td></tr><tr><td>LCD_RST</td><td style="text-align:left;">RESX</td><td style="text-align:left;">硬复位信号，低电平有效</td></tr><tr><td>LCD_WR</td><td style="text-align:left;">WRX</td><td style="text-align:left;">LCD写数据信号，低电平有效</td></tr><tr><td>LCD_CS</td><td style="text-align:left;">CSX</td><td style="text-align:left;">LCD片选信号，低电平有效</td></tr><tr><td>LCD_BL</td><td style="text-align:left;">-</td><td style="text-align:left;">LCD的背光信号，低电平点亮</td></tr></tbody></table><p>模块对外接口采用16位并口，颜色深度为16位，格式为RGB565，关系如下图：</p><img src="'+d+'" alt="image-20230519225138990" style="zoom:50%;"><h2 id="四、读写时序" tabindex="-1">四、读写时序 <a class="header-anchor" href="#四、读写时序" aria-label="Permalink to &quot;四、读写时序&quot;">​</a></h2><h3 id="_1-向ili9341写的时序" tabindex="-1">1. 向ILI9341写的时序 <a class="header-anchor" href="#_1-向ili9341写的时序" aria-label="Permalink to &quot;1. 向ILI9341写的时序&quot;">​</a></h3><p>我们可以看<a href="https://gitee.com/docs-site/scm-reference-guide/raw/master/10-%E6%98%BE%E7%A4%BA%E5%B1%8F%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/TFTLCD%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/01ILI9341_DS.pdf" target="_blank" rel="noreferrer">01ILI9341_DS.pdf</a> 的7.1.3. Write Cycle Sequence 一节：</p><img src="'+c+'" alt="image-20230519215250956" style="zoom:50%;"><p>（1）写命令时序由片选信号CSX拉低开始；</p><p>（2）对数据/命令选择信号线D/CX也置低电平，这表示写入的是命令地址(可理解为命令编码，如软件复位命令：0x01)；</p><p>（3）以写信号WRX为低，读信号RDX为高，表示数据传输方向为写入，在WR的上升沿，使D[17:0]上的数据写入到ILI9341里面。同时，在数据线D[17:0](或D[15:0])输出命令地址。</p><p>（4）在第二个传输阶段传送的是命令的参数，所以D/CX要置高电平，表示写入的是命令数据，命令数据是某些指令带有的参数，如复位指令编码为0x01，它后面可以带一个参数，该参数表示多少秒后复位(实际的复位命令不含参数，此处只是为了先了解一下指令编码与参数的区别)。</p><p>我们看一个更详细的图：</p><img src="'+o+'" alt="image-20230519215852281" style="zoom:50%;"><p>首先片选信号CS拉低，复位信号RES保持为高。 数据/命令切换信号D/C拉低，写信号引脚拉低，此时DB[15:0]发送的就是指令（黄色部分） ；数据/命令切换信号D/C拉高，写信号引脚拉低，此时DB[15:0]发送的就是一个像素点的颜色数据（ 红、绿、蓝部分） ，其中低5位为蓝色数据、中6位为绿色数据、高5位为红色数据。</p><h3 id="_2-从ili9341读的时序" tabindex="-1">2. 从ILI9341读的时序 <a class="header-anchor" href="#_2-从ili9341读的时序" aria-label="Permalink to &quot;2. 从ILI9341读的时序&quot;">​</a></h3><p>这里我们一般用的不多，这里简单提一下吧，我们可以看<a href="https://gitee.com/docs-site/scm-reference-guide/raw/master/10-%E6%98%BE%E7%A4%BA%E5%B1%8F%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/TFTLCD%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/01ILI9341_DS.pdf" target="_blank" rel="noreferrer">01ILI9341_DS.pdf</a> 的7.1.4. Read Cycle Sequence 一节：</p><img src="'+g+'" alt="image-20230519220200874" style="zoom:50%;"><p>先根据要读取的数据的类型，设置RS为高（数据）/低（命令），然后拉低片选，选中ILI9341，接着我们根据是读数据，置RD为低，然后读数据，在RD的上升沿， 读取数据线上的数据（D[15:0]）。</p><h2 id="五、命令与寄存器" tabindex="-1">五、命令与寄存器 <a class="header-anchor" href="#五、命令与寄存器" aria-label="Permalink to &quot;五、命令与寄存器&quot;">​</a></h2><p>这一部分我们可以查看<a href="https://gitee.com/docs-site/scm-reference-guide/raw/master/10-%E6%98%BE%E7%A4%BA%E5%B1%8F%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/TFTLCD%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/01ILI9341_DS.pdf" target="_blank" rel="noreferrer">01ILI9341_DS.pdf</a> 的8. Command一节，这个后边开始学习驱动LCD的代码的时候结合来看会更加容易理解。这里简单学习几个吧。学到这里，其实觉得挺奇怪的，在芯片手册中，没有看到寄存器的相关概念，也可能是我没有仔细看吧，手册中都是一些命令，但是这些命令控制的应该都是寄存器才对，所以后边这些的话，就可以看作是命令去控制的寄存器。</p><h3 id="_1-命令格式说明" tabindex="-1">1. 命令格式说明 <a class="header-anchor" href="#_1-命令格式说明" aria-label="Permalink to &quot;1. 命令格式说明&quot;">​</a></h3><p>ILI9341所有的指令都是 8 位的（高 8 位无效），且参数除了读写GRAM的时候是 16 位，其他操作参数，都是 8 位的。</p><h3 id="_2-read-id4-d3h" tabindex="-1">2. Read ID4 (D3h) <a class="header-anchor" href="#_2-read-id4-d3h" aria-label="Permalink to &quot;2. Read ID4 (D3h)&quot;">​</a></h3><p>该指令为读ID4指令，用于读取LCD控制器的ID 。因此，同一个代码，可以根据ID的不同，执行不同的LCD驱动初始化，以兼容不同的LCD屏幕。</p><img src="'+h+'" alt="image-20230519225401282" style="zoom:50%;"><h3 id="_3-memory-access-control-36h" tabindex="-1">3. Memory Access Control (36h) <a class="header-anchor" href="#_3-memory-access-control-36h" aria-label="Permalink to &quot;3. Memory Access Control (36h)&quot;">​</a></h3><p>该指令为存储访问控制指令，可以控制ILI9341存储器的读写方向，简单的说，就是在连续写GRAM的时候，可以控制GRAM指针的增长方向，从而控制显示方式（读GRAM也是一样）。</p><img src="'+m+'" alt="image-20230519225604394" style="zoom:50%;"><h3 id="_4-column-address-set-2ah" tabindex="-1">4. Column Address Set (2Ah) <a class="header-anchor" href="#_4-column-address-set-2ah" aria-label="Permalink to &quot;4. Column Address Set (2Ah)&quot;">​</a></h3><p>该指令是列地址设置指令，在从左到右，从上到下的扫描方式（默认）下面，该指令用于设置横坐标（x坐标）：</p><img src="'+y+'" alt="image-20230519225636754" style="zoom:50%;"><p>在默认扫描方式时，该指令用于设置x坐标，该指令带有4个参数，实际上是2个坐标值：SC和EC，即列地址的起始值和结束值，SC必须小于等于EC，且0≤SC/EC≤239。一般在设置x坐标的时候，我们只需要带2个参数即可，也就是设置SC即可，因为如果EC没有变化，我们只需要设置一次即可（在初始化ILI9341的时候设置），从而提高速度。</p><h3 id="_5-page-address-set-2bh" tabindex="-1">5. Page Address Set (2Bh) <a class="header-anchor" href="#_5-page-address-set-2bh" aria-label="Permalink to &quot;5. Page Address Set (2Bh)&quot;">​</a></h3><p>该指令是页地址设置指令，在从左到右，从上到下的扫描方式（默认）下面，该指令用于设置纵坐标（y坐标）：</p><img src="'+x+'" alt="image-20230519225718890" style="zoom:50%;"><p>在默认扫描方式时，该指令用于设置y坐标，该指令带有4个参数，实际上是2个坐标值：SP和EP，即页地址的起始值和结束值，SP必须小于等于EP，且0≤SP/EP≤319。一般在设置y坐标的时候，我们只需要带2个参数即可，也就是设置SP即可，因为如果EP没有变化，我们只需要设置一次即可（在初始化ILI9341的时候设置），从而提高速度。</p><h3 id="_6-memory-write-2ch" tabindex="-1">6. Memory Write (2Ch) <a class="header-anchor" href="#_6-memory-write-2ch" aria-label="Permalink to &quot;6. Memory Write (2Ch)&quot;">​</a></h3><p>该指令是写GRAM指令，在发送该指令之后，我们便可以往LCD的GRAM里面写入颜色数据了，该指令支持连续写 (地址自动递增)：</p><img src="'+p+'" alt="image-20230519225754328" style="zoom:50%;"><p>在收到指令0X2C之后，数据有效位宽变为16位，我们可以连续写入LCD GRAM值，而GRAM的地址将根据MY/MX/MV设置的扫描方向进行自增。例如：假设设置的是从左到右，从上到下的扫描方式，那么设置好起始坐标（通过SC，SP设置）后，每写入一个颜色值，GRAM地址将会自动自增1（SC++），如果碰到EC，则回到SC，同时SP++，一直到坐标：EC，EP结束，其间无需再次设置的坐标，从而大大提高写入速度。</p><h3 id="_7-memory-read-2eh" tabindex="-1">7. Memory Read (2Eh) <a class="header-anchor" href="#_7-memory-read-2eh" aria-label="Permalink to &quot;7. Memory Read (2Eh)&quot;">​</a></h3><p>该指令是读GRAM指令，用于读取ILI9341的显存（GRAM），同0X2C指令，该指令支持连续读 (地址自动递增)：</p><img src="'+_+'" alt="image-20230519225832833" style="zoom:50%;"><p>ILI9341在收到该指令后，第一次输出的是dummy数据（无效），第二次开始，读取到的才是有效的GRAM数据（从坐标：SC，SP开始），输出规律为：每个颜色分量占8个位，一次输出2个颜色分量。比如：第一次输出是R1G1，随后的规律为：B1R2→G2B2→R3G3→B3R4→G4B4→R5G5... 以此类推</p><h2 id="六、内存显示地址映射" tabindex="-1">六、内存显示地址映射 <a class="header-anchor" href="#六、内存显示地址映射" aria-label="Permalink to &quot;六、内存显示地址映射&quot;">​</a></h2><p>这一部分可以参考<a href="https://gitee.com/docs-site/scm-reference-guide/raw/master/10-%E6%98%BE%E7%A4%BA%E5%B1%8F%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/TFTLCD%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/01ILI9341_DS.pdf" target="_blank" rel="noreferrer">01ILI9341_DS.pdf</a> 的9.2. Memory to Display Address Mapping 一节，对后边理解扫描方向会有好处。其实这一部分笔记有一些是从网上看的，有一些概念看的我挺不明所以的，后来来起来按照我自己的理解，这里GRAM是一个虚拟内存，缓存我们要显示的数据，我们通过MCU向GRAM写入数据，然后LCD屏幕会有一个类似“电子枪”的东西，从GRAM中取出像素点的数据，然后按照特定的扫描方式，点亮LCD面板的真实像素点，这些真实的像素点，按照我自己的理解，我觉得可以理解成LCD的物理内存。</p><h3 id="_1-gram与lcd面板" tabindex="-1">1. GRAM与LCD面板 <a class="header-anchor" href="#_1-gram与lcd面板" aria-label="Permalink to &quot;1. GRAM与LCD面板&quot;">​</a></h3><p>这里的模式为Normal Display ON or Partial Mode ON, Vertical Scroll Mode OFF，也就是说下图只讨论“正常显示”，不讨论“垂直滚动显示”模式。</p><img src="'+D+'" alt="image-20230523221724206" style="zoom:67%;"><p>可以看到GRAM内存被两个指针访问，行指针和列指针，行指针范围从0000h到0013Fh（换算成十进制就是0到319，一共320行），列指针范围为0000h到00EFh（换算成十进制就是0到239，一共240列）。也就是说，GRAM和LCD像素面板的对应关系是一种竖屏（240*320）的对应的关系。至于如何让GRAM数据显示到LCD屏上，不需要我们去考虑，只要知道这种对应关系就可以了。我们要是想要在最左上角显示一个点，可以将将点数据存储在GRAM(列指针，页指针)=(0,0)处。</p><p>当实际将GRAM中的数据刷新到LCD屏进行显示的时候，ILI9341有8种显示方式：左上角→右下角（竖屏）、左下角→右上角（竖屏）、右上角→左下角（竖屏）、右下角→左上角（竖屏）、左上角→右下角（横屏）、左下角→右上角（横屏）、右上角-→左下角（横屏）、右下角→左上角（横屏），既然GRAM与LCD像素面板的点是固定对应的，那么不同的显示模式又是怎么实现的呢？</p><p>按照我自己的理解，GRAM与LCD面板的像素点的地址是一一对应的，这个对应关系是无法被改变的，前边我们知道，要想显示一幅图像，有一个行同步信号，比如就从左上角开始显示，当显示完一行的时候，会自动进行下一行的显示，显示完一帧图像的时候，会产生一个帧同步信号，进行下一帧的显示，此时就显示到了右下角。当然这里的<strong>扫描针对的是LCD显示屏</strong>，而非GRAM，可以想象一下，我们有一个写在GRAM(0,0)位置的像素点，现在我们要开始显示，我们在LCD屏的右下角开始显示，那么读取的这一个像素的数据就会被显示到LCD屏的右下角。</p><h3 id="_2-mcu对gram的写-读方向" tabindex="-1">2. MCU对GRAM的写/读方向 <a class="header-anchor" href="#_2-mcu对gram的写-读方向" aria-label="Permalink to &quot;2. MCU对GRAM的写/读方向&quot;">​</a></h3><img src="'+M+'" alt="image-20230523222310976" style="zoom:50%;"><p>从这张图可以看出，我们通过MCU向GRAM写入数据的时候，数据按照上面所示的顺序写入，B为起始点，E为结束点，按照从左到右，从上到下的顺序进行写入，写入完一行数据后，切换到下一行进行显示。</p><p>接下来就是将GRAM中的数据刷新到到LCD的像素面板（也可以称之为物理内存吧，目前我是这么认为的）进行显示，在物理内存中写入数据的计数器由“Memory Data Access Control（36h）”命令控制，B5、B6和B7位如下所述：</p><img src="'+E+'" alt="image-20230524123443366" style="zoom:43%;"><p>从图中可以看出，B5位对应的是 MADCTL (Memory Access Control) 寄存器中的D5，表示交换行列，B6对应的是D6，表示列地址顺序，B7对应的是D7，表示的是行地址顺序。多以这里的B[7:5]就对应MADCTL 的D[7:5]，这三位共同决定了LCD的八种扫描方式。图中的四个角有四个说明，它们都是在不关心行列交换的情况下，另外两位取不同值的时候整个LCD显示的时候扫描的起始点。比如，B6=0，B7=1，这个时候LCD开始显示的时候，起始点就是左下角的（0,319），对于虚拟地址来说就会显示GRAM中(0, 0)这个位置的数据，当然，这个值是针对竖屏240*320来讲的。</p><p>详细的GRAM中的虚拟地址到LCD中的物理地址的转换关系如下表：</p><img src="'+C+'" alt="image-20230524124345341" style="zoom:50%;"><p>于是我们从GRAM到LCD就有8种扫描模式啦。</p><h3 id="_3-8种显示方向" tabindex="-1">3. 8种显示方向 <a class="header-anchor" href="#_3-8种显示方向" aria-label="Permalink to &quot;3. 8种显示方向&quot;">​</a></h3><p>一些说明：</p><p>（1）MV、MX、MY的控制位在命令 0x36 对应的寄存器中</p><p>（2）Image in the Memory（MPU）中描述的是在MCU的240（宽）* 320（高）* 16bit（RGB565显示方式）中显示了一个图像“F”。</p><p>（3）Image In the Driver（Frame Memory）描述的是经过虚拟地址到物理地址转换器后，实际传输到GRAM中的数据显示阵列。</p><p>（4）B、E分别描述了MCU传输的数据流的起始位置和终止位置，下边的图都是来自于<a href="https://gitee.com/docs-site/scm-reference-guide/raw/master/10-%E6%98%BE%E7%A4%BA%E5%B1%8F%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/TFTLCD%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/01ILI9341_DS.pdf" target="_blank" rel="noreferrer">01ILI9341_DS.pdf</a> 的9.3. MCU to memory write/read direction一节。这里需要注意，<strong>从GRAM读取像素点的数据，这个顺序按照从左到右，从上到下的顺序进行，然后送到LCD显示的时候，根据MY、MX和MV三个位的不同值，从指定的位置开始，到这个位置的对角结束，按照先行后列的方式进行扫描显示</strong>。</p><p>其实不论哪种显示方向，其实并没有改变GRAM物理内存与LCD显示屏的对应关系，也即是说GRAM物理内存与显示屏之间的对应关系、内存到LCD的扫描方式，是固定不变的。那么这种显示方向是怎么出现的？</p><p>实际上，<strong>显示方向说的是MCU的显示缓存MPU（或者MCU读写GRAM的数据流）与LCD显示屏的对应关系。由于GRAM地址与LCD显示屏像素点的物理地址的对应关系是不会改变的。</strong></p><p>用户在写程序的过程中，LCD显示操作是更改MPU的内容，至于MPU到GRAM的传输是驱动程序完成的，就是前边学习的8080时序。也就是说，用户控制显示的内容，接触的是MPU（其实就是GRAM啦），而更改显示方向需要配置ILI9341的寄存器。其实，ILI9341的扫描方向的功能也可以没有，但是这个时候要想改变显示的方向之类的，需要用户自己软件进行转换，直接在GRAM中进行转换，然后刷新到LCD屏幕，其实ILI9341配置的那3位就相当于帮我们做了一个转换关系表，这样就不用我们自己去配置了。</p><h4 id="_3-1-normal" tabindex="-1">3.1 Normal <a class="header-anchor" href="#_3-1-normal" aria-label="Permalink to &quot;3.1 Normal&quot;">​</a></h4><img src="'+b+'" alt="image-20230523223202157" style="zoom:67%;"><p>这是正常的模式，以(x，y)表示(列地址，行地址)，那么MCU向（0，0）写入数据，经过虚拟地址到物理地址的转换，实际写入到GRAM的地址是（0，0），对应LCD的左上角。MCU向（239，319）写入数据，经过虚拟地址到物理地址的转换，实际写入到GRAM的地址是（239,319），对应LCD的右下角。</p><img src="'+L+'" alt="image-20230523224446808" style="zoom:33%;"><table tabindex="0"><thead><tr><th style="text-align:center;">B[7:5]</th><th style="text-align:center;">D[7:5]</th><th style="text-align:center;">MY</th><th style="text-align:center;">MX</th><th style="text-align:center;">MV</th><th style="text-align:center;">D[7:5]十进制</th></tr></thead><tbody><tr><td style="text-align:center;">000</td><td style="text-align:center;">000</td><td style="text-align:center;">0</td><td style="text-align:center;">0</td><td style="text-align:center;">0</td><td style="text-align:center;">0</td></tr></tbody></table><h4 id="_3-2-y-mirror" tabindex="-1">3.2 Y-Mirror <a class="header-anchor" href="#_3-2-y-mirror" aria-label="Permalink to &quot;3.2 Y-Mirror&quot;">​</a></h4><img src="'+f+'" alt="image-20230523223509624" style="zoom:67%;"><p>这是Y镜像，也就是行地址翻转的情况，以(x，y)表示(列地址，行地址)，那么MCU向（0，0）写入数据，经过虚拟地址到物理地址的转换，实际写入到GRAM的地址是（0，319），对应LCD的左下角：</p><img src="'+I+'" alt="image-20230524130422020"><p>MCU向（239，319）写入数据，经过虚拟地址到物理地址的转换，实际写入到GRAM的地址是（239，0），对应LCD的右上角。最终的效果就是LCD的显示实现了Y方向上的翻转。</p><img src="'+B+'" alt="image-20230523224720981" style="zoom:33%;"><table tabindex="0"><thead><tr><th style="text-align:center;">B[7:5]</th><th style="text-align:center;">D[7:5]</th><th style="text-align:center;">MY</th><th style="text-align:center;">MX</th><th style="text-align:center;">MV</th><th style="text-align:center;">D[7:5]十进制</th></tr></thead><tbody><tr><td style="text-align:center;">100</td><td style="text-align:center;">100</td><td style="text-align:center;">1</td><td style="text-align:center;">0</td><td style="text-align:center;">0</td><td style="text-align:center;">4</td></tr></tbody></table><h4 id="_3-3-x-mirror" tabindex="-1">3.3 X-Mirror <a class="header-anchor" href="#_3-3-x-mirror" aria-label="Permalink to &quot;3.3 X-Mirror&quot;">​</a></h4><img src="'+u+'" alt="image-20230523223647692" style="zoom:67%;"><table tabindex="0"><thead><tr><th style="text-align:center;">B[7:5]</th><th style="text-align:center;">D[7:5]</th><th style="text-align:center;">MY</th><th style="text-align:center;">MX</th><th style="text-align:center;">MV</th><th style="text-align:center;">D[7:5]十进制</th></tr></thead><tbody><tr><td style="text-align:center;">010</td><td style="text-align:center;">010</td><td style="text-align:center;">0</td><td style="text-align:center;">1</td><td style="text-align:center;">0</td><td style="text-align:center;">2</td></tr></tbody></table><h4 id="_3-4-x-y-mirror" tabindex="-1">3.4 X/Y-Mirror <a class="header-anchor" href="#_3-4-x-y-mirror" aria-label="Permalink to &quot;3.4 X/Y-Mirror&quot;">​</a></h4><img src="'+R+'" alt="image-20230523223825411" style="zoom:67%;"><table tabindex="0"><thead><tr><th style="text-align:center;">B[7:5]</th><th style="text-align:center;">D[7:5]</th><th style="text-align:center;">MY</th><th style="text-align:center;">MX</th><th style="text-align:center;">MV</th><th style="text-align:center;">D[7:5]十进制</th></tr></thead><tbody><tr><td style="text-align:center;">110</td><td style="text-align:center;">110</td><td style="text-align:center;">1</td><td style="text-align:center;">1</td><td style="text-align:center;">0</td><td style="text-align:center;">6</td></tr></tbody></table><h4 id="_3-5-x-y-exchange" tabindex="-1">3.5 X-Y Exchange <a class="header-anchor" href="#_3-5-x-y-exchange" aria-label="Permalink to &quot;3.5 X-Y Exchange&quot;">​</a></h4><img src="'+A+'" alt="image-20230523223947867" style="zoom:67%;"><p>这是XY交换，也就是行列地址交换的情况，以(x，y)表示(列地址，行地址)，MCU向（0，0）写入数据，经过虚拟地址到物理地址的转换，实际写入到GRAM的地址是（0,0），对应LCD的左上角。MCU向（239，319）写入数据，经过虚拟地址到物理地址的转换，实际写入到GRAM的地址是（319，239），对应LCD的右下角。经过这样的变换，LCD就从原来的竖屏变成了横屏显示。最终的效果就是LCD的显示实现了行列的交换。</p><table tabindex="0"><thead><tr><th style="text-align:center;">B[7:5]</th><th style="text-align:center;">D[7:5]</th><th style="text-align:center;">MY</th><th style="text-align:center;">MX</th><th style="text-align:center;">MV</th><th style="text-align:center;">D[7:5]十进制</th></tr></thead><tbody><tr><td style="text-align:center;">001</td><td style="text-align:center;">001</td><td style="text-align:center;">0</td><td style="text-align:center;">0</td><td style="text-align:center;">1</td><td style="text-align:center;">1</td></tr></tbody></table><h4 id="_3-6-x-y-exchange-y-mirror" tabindex="-1">3.6 X-Y Exchange Y-Mirror <a class="header-anchor" href="#_3-6-x-y-exchange-y-mirror" aria-label="Permalink to &quot;3.6 X-Y Exchange Y-Mirror&quot;">​</a></h4><img src="'+G+'" alt="image-20230523224100259" style="zoom:67%;"><table tabindex="0"><thead><tr><th style="text-align:center;">B[7:5]</th><th style="text-align:center;">D[7:5]</th><th style="text-align:center;">MY</th><th style="text-align:center;">MX</th><th style="text-align:center;">MV</th><th style="text-align:center;">D[7:5]十进制</th></tr></thead><tbody><tr><td style="text-align:center;">101</td><td style="text-align:center;">101</td><td style="text-align:center;">1</td><td style="text-align:center;">0</td><td style="text-align:center;">1</td><td style="text-align:center;">5</td></tr></tbody></table><h4 id="_3-7-xy-exchange-x-mirror" tabindex="-1">3.7 XY Exchange X-Mirror <a class="header-anchor" href="#_3-7-xy-exchange-x-mirror" aria-label="Permalink to &quot;3.7 XY Exchange X-Mirror&quot;">​</a></h4><img src="'+S+'" alt="image-20230523224159218" style="zoom:67%;"><table tabindex="0"><thead><tr><th style="text-align:center;">B[7:5]</th><th style="text-align:center;">D[7:5]</th><th style="text-align:center;">MY</th><th style="text-align:center;">MX</th><th style="text-align:center;">MV</th><th style="text-align:center;">D[7:5]十进制</th></tr></thead><tbody><tr><td style="text-align:center;">011</td><td style="text-align:center;">011</td><td style="text-align:center;">0</td><td style="text-align:center;">1</td><td style="text-align:center;">1</td><td style="text-align:center;">3</td></tr></tbody></table><h4 id="_3-8-xy-exchange-xy-mirror" tabindex="-1">3.8 XY Exchange XY-Mirror <a class="header-anchor" href="#_3-8-xy-exchange-xy-mirror" aria-label="Permalink to &quot;3.8 XY Exchange XY-Mirror&quot;">​</a></h4><img src="'+q+'" alt="image-20230523224301780" style="zoom:67%;"><table tabindex="0"><thead><tr><th style="text-align:center;">B[7:5]</th><th style="text-align:center;">D[7:5]</th><th style="text-align:center;">MY</th><th style="text-align:center;">MX</th><th style="text-align:center;">MV</th><th style="text-align:center;">D[7:5]十进制</th></tr></thead><tbody><tr><td style="text-align:center;">111</td><td style="text-align:center;">111</td><td style="text-align:center;">1</td><td style="text-align:center;">1</td><td style="text-align:center;">1</td><td style="text-align:center;">7</td></tr></tbody></table><h4 id="_3-9-八种显示方向对应关系" tabindex="-1">3.9 八种显示方向对应关系 <a class="header-anchor" href="#_3-9-八种显示方向对应关系" aria-label="Permalink to &quot;3.9 八种显示方向对应关系&quot;">​</a></h4><table tabindex="0"><thead><tr><th style="text-align:center;">B[7:5]</th><th style="text-align:center;">D[7:5]</th><th style="text-align:center;">MY</th><th style="text-align:center;">MX</th><th style="text-align:center;">MV</th><th style="text-align:center;">D[7:5]十进制</th><th style="text-align:center;">模式说明</th><th style="text-align:center;">图片对应</th></tr></thead><tbody><tr><td style="text-align:center;">000</td><td style="text-align:center;">000</td><td style="text-align:center;">0</td><td style="text-align:center;">0</td><td style="text-align:center;">0</td><td style="text-align:center;">0</td><td style="text-align:center;">Normal</td><td style="text-align:center;"><img src="'+P+'" alt="image-20230524133046886" style="zoom:67%;"></td></tr><tr><td style="text-align:center;">001</td><td style="text-align:center;">001</td><td style="text-align:center;">0</td><td style="text-align:center;">0</td><td style="text-align:center;">1</td><td style="text-align:center;">1</td><td style="text-align:center;">X-Y Exchange</td><td style="text-align:center;"><img src="'+k+'" alt="image-20230524133125714" style="zoom:67%;"></td></tr><tr><td style="text-align:center;">010</td><td style="text-align:center;">010</td><td style="text-align:center;">0</td><td style="text-align:center;">1</td><td style="text-align:center;">0</td><td style="text-align:center;">2</td><td style="text-align:center;">X-Mirror</td><td style="text-align:center;"><img src="'+F+'" alt="image-20230524133202987" style="zoom:67%;"></td></tr><tr><td style="text-align:center;">011</td><td style="text-align:center;">011</td><td style="text-align:center;">0</td><td style="text-align:center;">1</td><td style="text-align:center;">1</td><td style="text-align:center;">3</td><td style="text-align:center;">XY Exchange X-Mirror</td><td style="text-align:center;"><img src="'+X+'" alt="image-20230524215000828" style="zoom:67%;"></td></tr><tr><td style="text-align:center;">100</td><td style="text-align:center;">100</td><td style="text-align:center;">1</td><td style="text-align:center;">0</td><td style="text-align:center;">0</td><td style="text-align:center;">4</td><td style="text-align:center;">Y-Mirror</td><td style="text-align:center;"><img src="'+Y+'" alt="image-20230524215142332" style="zoom:67%;"></td></tr><tr><td style="text-align:center;">101</td><td style="text-align:center;">101</td><td style="text-align:center;">1</td><td style="text-align:center;">0</td><td style="text-align:center;">1</td><td style="text-align:center;">5</td><td style="text-align:center;">X-Y Exchange Y-Mirror</td><td style="text-align:center;"><img src="'+z+'" alt="image-20230524215313557" style="zoom:67%;"></td></tr><tr><td style="text-align:center;">110</td><td style="text-align:center;">110</td><td style="text-align:center;">1</td><td style="text-align:center;">1</td><td style="text-align:center;">0</td><td style="text-align:center;">6</td><td style="text-align:center;">X/Y-Mirror</td><td style="text-align:center;"><img src="'+T+'" alt="image-20230524215421446" style="zoom:67%;"></td></tr><tr><td style="text-align:center;">111</td><td style="text-align:center;">111</td><td style="text-align:center;">1</td><td style="text-align:center;">1</td><td style="text-align:center;">1</td><td style="text-align:center;">7</td><td style="text-align:center;">XY Exchange XY-Mirror</td><td style="text-align:center;"><img src="'+U+'" alt="image-20230524215619493" style="zoom:67%;"></td></tr></tbody></table>',123)])])}const K=e(V,[["render",w]]);export{H as __pageData,K as default};
