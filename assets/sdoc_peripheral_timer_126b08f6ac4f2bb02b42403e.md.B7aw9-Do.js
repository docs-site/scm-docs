import{_ as e,c as t,o as i,b0 as r}from"./chunks/framework.C5ev1SXp.js";const s="/scm-docs/assets/image-20240114125720472.w1G3bMeA.png",o="/scm-docs/assets/image-20240114125822967.B8WmhHQY.png",l="/scm-docs/assets/image-20240114125901264.VwWbPb7h.png",c="/scm-docs/assets/image-20240114125944586.BrZ7-Ayy.png",m="/scm-docs/assets/image-20240114130039912.oY_w6Sdx.png",_="/scm-docs/assets/image-20240114130130529.BSfEbNPv.png",n="/scm-docs/assets/image-20240114130200927.Cfw_Wcvn.png",u=JSON.parse('{"title":"LV075-高级定时器PWM输出","description":null,"frontmatter":{"title":"LV075-高级定时器PWM输出","date":"2025-09-21T18:43:35.000Z","icon":"famicons:logo-markdown","permalink":"/sdoc/peripheral/timer/126b08f6ac4f2bb02b42403e","index":true,"tags":null,"categories":null,"copyright":false,"keywords":null,"cover":null,"comments":null,"mathjax":null,"top":null,"description":null,"tdoc":{"detailDate":"2025-09-21T18:43:35.699Z","fulluuid":"02b42403e6334b1e88b3aefe535488bf","useduuid":"02b42403e"}},"headers":[],"relativePath":"sdoc/peripheral/timer/126b08f6ac4f2bb02b42403e.md","filePath":"sdoc/20-基本外设篇/15-定时器/LV075-高级定时器PWM输出.md","lastUpdated":1758153691000}'),p={name:"sdoc/peripheral/timer/126b08f6ac4f2bb02b42403e.md"};function M(d,a,h,x,C,T){return i(),t("div",null,[...a[0]||(a[0]=[r('<h1 id="lv075-高级定时器pwm输出" tabindex="-1">LV075-高级定时器PWM输出 <a class="header-anchor" href="#lv075-高级定时器pwm输出" aria-label="Permalink to &quot;LV075-高级定时器PWM输出&quot;">​</a></h1><h2 id="一、基本原理" tabindex="-1">一、基本原理 <a class="header-anchor" href="#一、基本原理" aria-label="Permalink to &quot;一、基本原理&quot;">​</a></h2><p>要实现定时器输出指定个数 PWM，只需要掌握下面几点内容：</p><ul><li><p>第一，定时器是如何输出 PWM 的，这部分的知识和前面是一样的。但是需要注意的是：我们需要把 MOE 位置 1，这样高级定时器的通道才能输出。</p></li><li><p>第二，要清楚重复计数器特性，设置重复计数器寄存器 RCR 的值为 N，那么更新事件将在定时器发生 N+1 次上溢或下溢时发生。换句话来说就是，想要指定输出 N 个 PWM，只需要把N-1 写入 RCR 寄存器。因为在边沿对齐模式下，定时器溢出周期对应着 PWM 周期，我们只要在更新事件发生时，停止输出 PWM 就行。</p></li><li><p>第三，为了保证定时器输出指定个数的 PWM 后，定时器马上停止继续输出，我们使能更新中断，并在定时器中断里关闭计数器。</p></li></ul><h2 id="二、相关寄存器" tabindex="-1">二、相关寄存器 <a class="header-anchor" href="#二、相关寄存器" aria-label="Permalink to &quot;二、相关寄存器&quot;">​</a></h2><p>下面了解一下 TIM1/TIM8 这些高级定时器中使用到的几个重要的寄存器，其他更多关于定时器的资料可以参考《STM32F10xxx 参考手册_V10（中文版） .pdf》 的第 13 章。</p><h3 id="_1-控制寄存器-1-timx-cr1" tabindex="-1">1. 控制寄存器 1（TIMx_CR1） <a class="header-anchor" href="#_1-控制寄存器-1-timx-cr1" aria-label="Permalink to &quot;1. 控制寄存器 1（TIMx_CR1）&quot;">​</a></h3><p>TIM1/TIM8 的控制寄存器 1 描述如图：</p><img src="'+s+'" alt="image-20240114125720472" style="zoom:50%;"><p>上图中我们只列出了需要用的一些位， 其中：位 7（APRE）用于控制自动重载寄存器是否具有缓冲作用，在基本定时器的时候已经学习过了。 在本实验中我们把该位要置 1，这样就算改变 ARR 寄存器的值，该值也不会马上生效，而是等待之前设置的 PWM 完整输出后（发生更新事件）才生效。位 4（DIR）用于配置计数器的计数方向，这里我们默认置 0。位 0（CEN），用于使能计数器的工作，必须要设置该位为 1，才可以开始计数。</p><h3 id="_2-捕获-比较模式寄存器-1-2-timx-ccmr1-2" tabindex="-1">2. 捕获/比较模式寄存器 1/2（TIMx_CCMR1/2） <a class="header-anchor" href="#_2-捕获-比较模式寄存器-1-2-timx-ccmr1-2" aria-label="Permalink to &quot;2. 捕获/比较模式寄存器 1/2（TIMx_CCMR1/2）&quot;">​</a></h3><p>TIM1/TIM8 的捕获/比较模式寄存器（ TIMx_CCMR1/2），该寄存器一般有 2 个： TIMx_CCMR1 和 TIMx _CCMR2。 TIMx_CCMR1 控制 CH1 和 CH2，而 TIMx_CCMR2 控制 CH3 和CH4。 TIMx_CCMR1 寄存器描述如图：</p><img src="'+o+'" alt="image-20240114125822967" style="zoom:50%;"><p>该寄存器的有些位在不同模式下，功能不一样，我们前面已经说过。比如我们要让 TIM1 的CH1 输出 PWM 波为例，该寄存器的模式设置位 OC1M[2:0]就是对应着通道 1 的模式设置，此部分由 3 位组成,总共可以配置成 8 种模式，我们使用的是 PWM 模式，所以这 3 位必须设置为110 或者 111，分别对应 PWM 模式 1 和 PWM 模式 2。这两种 PWM 模式的区别就是输出有效电平的极性相反，这里我们设置为 PWM 模式 1。位 3 OC1PE 是输出比较通道 1 的预装使能，该位需要置 1，另外 CC1S[1:0]用于设置通道 1 的方向（输入/输出）默认设置为 0，就是设置通道作为输出使用。</p><h3 id="_3-捕获-比较使能寄存器-timx-ccer" tabindex="-1">3. 捕获/比较使能寄存器（TIMx_ CCER） <a class="header-anchor" href="#_3-捕获-比较使能寄存器-timx-ccer" aria-label="Permalink to &quot;3. 捕获/比较使能寄存器（TIMx_ CCER）&quot;">​</a></h3><p>TIM1/TIM8 的捕获/比较使能寄存器，该寄存器控制着各个输入输出通道的开关。TIMx_CCER 寄存器描述如图：</p><img src="'+l+'" alt="image-20240114125901264" style="zoom:50%;"><p>该寄存器比较简单，要让 TIM1 的 CH1 输出 PWM 波，这里我们要使能 CC1E 位，该位是通道 1 输入/输出使能位，要想 PWM 从 IO 口输出，这个位必须设置为 1。 CC1P 位是设置通道1 的输出极性，我们设置 0，即 OC1 高电平有效。</p><h3 id="_4-事件产生寄存器-timx-egr" tabindex="-1">4. 事件产生寄存器（TIMx_ EGR） <a class="header-anchor" href="#_4-事件产生寄存器-timx-egr" aria-label="Permalink to &quot;4. 事件产生寄存器（TIMx_ EGR）&quot;">​</a></h3><p>TIM1/TIM8 的事件产生寄存器， 该寄存器作用是让用户用软件方式产生各类事件。TIMx_EGR 寄存器描述如图：</p><img src="'+c+'" alt="image-20240114125944586" style="zoom:50%;"><p>UG 位是更新事件的控制位，作用和定时器溢出时产生的更新事件一样，区别是这里是通过软件产生的，而定时器溢出是硬件自己完成的。只有开启了更新中断，这两种方式都可以产更新中断。本实验用到该位去产生软件更新器事件，在需要的时候把 UG 位置 1 即可，会由硬件自动清零。</p><h3 id="_5-重复计数器寄存器-timx-rcr" tabindex="-1">5. 重复计数器寄存器（TIMx_ RCR） <a class="header-anchor" href="#_5-重复计数器寄存器-timx-rcr" aria-label="Permalink to &quot;5. 重复计数器寄存器（TIMx_ RCR）&quot;">​</a></h3><p>重复计数器寄存器用于设置重复计数器值，因为它具有影子寄存器，所以它本身只是起缓冲作用。当更新事件发生时，该寄存器的值会转移到其影子寄存器中，从而真正起作用。 TIMx_RCR 寄存器描述如图:</p><img src="'+m+'" alt="image-20240114130039912" style="zoom:50%;"><p>该寄存器的 REP[7:0]位是低 8 位有效，即最大值 255。因为这个寄存器只是起缓冲作用，如果想要对该寄存器写入值后立即生效，可以通过对 UG 位写 1，产生软件更新事件。</p><h3 id="_6-捕获-比较寄存器-1-2-3-4-timx-ccr1-2-3-4" tabindex="-1">6. 捕获/比较寄存器 1/2/3/4（TIMx_CCR1/2/3/4） <a class="header-anchor" href="#_6-捕获-比较寄存器-1-2-3-4-timx-ccr1-2-3-4" aria-label="Permalink to &quot;6. 捕获/比较寄存器 1/2/3/4（TIMx_CCR1/2/3/4）&quot;">​</a></h3><p>捕获/比较寄存器（TIMx_CCR1/2/3/4），该寄存器总共有 4 个，对应 4 个通道 CH1~CH4。我们使用的是通道 1，所以来看看 TIMx_CCR1 寄存器的描述， 如图 ：</p><img src="'+_+'" alt="image-20240114130130529" style="zoom:50%;"><p>在输出模式下，捕获/比较寄存器影子寄存器的值与 CNT 的值比较，根据比较结果产生相应动作，利用这点，我们通过修改这个寄存器的值，就可以控制 PWM 的占空比了。</p><h3 id="_7-断路和死区寄存器-timx-bdtr" tabindex="-1">7. 断路和死区寄存器（TIMx_ BDTR） <a class="header-anchor" href="#_7-断路和死区寄存器-timx-bdtr" aria-label="Permalink to &quot;7. 断路和死区寄存器（TIMx_ BDTR）&quot;">​</a></h3><p>高级定时器 TIM1/8 的通道用作输出时，还必须配置断路和死区寄存器（TIMx_BDTR） 的位 MOE，该寄存器各位描述如图 ：</p><img src="'+n+'" alt="image-20240114130200927" style="zoom:50%;"><p>在这个实验中，我们只需要关注该寄存器的位 15（MOE），要想高级定时器的 PWM 正常输出，则必须设置 MOE 位为 1，否则不会有输出。</p>',34)])])}const I=e(p,[["render",M]]);export{u as __pageData,I as default};
