import{_ as a,c as e,o as i,b0 as s}from"./chunks/framework.C5ev1SXp.js";const r="/scm-docs/assets/image-20230507122145166.eMXiqChJ.png",l="/scm-docs/assets/image-20230507125856205.BdYMXN6z.png",d="/scm-docs/assets/image-20230507131203330.DedrpnWC.png",n="/scm-docs/assets/image-20230507131219435.DfbRudQj.png",o="/scm-docs/assets/image-20230507131440446.C4YBZJVw.png",c="/scm-docs/assets/image-20230507131453955.D0Ov3SHV.png",h="/scm-docs/assets/image-20230507131505419.ZziJ6VGD.png",A=JSON.parse('{"title":"LV010-AT24C02简介","description":null,"frontmatter":{"title":"LV010-AT24C02简介","date":"2025-09-25T22:33:11.000Z","icon":"famicons:logo-markdown","permalink":"/sdoc/peripheral/i2c/126b09344d8f021f00cacd6c","index":true,"tags":null,"categories":null,"copyright":false,"keywords":null,"cover":null,"comments":null,"mathjax":null,"top":null,"description":null,"tdoc":{"detailDate":"2025-09-25T22:33:11.033Z","fulluuid":"f00cacd6ccbd4a459325107dc47b447a","useduuid":"f00cacd6c"}},"headers":[],"relativePath":"sdoc/peripheral/i2c/126b09344d8f021f00cacd6c.md","filePath":"sdoc/20-基本外设篇/30-I2C/LV010-AT24C02简介.md","lastUpdated":1758811394000}'),p={name:"sdoc/peripheral/i2c/126b09344d8f021f00cacd6c.md"};function m(k,t,g,u,b,x){return i(),e("div",null,[...t[0]||(t[0]=[s('<h1 id="lv010-at24c02简介" tabindex="-1">LV010-AT24C02简介 <a class="header-anchor" href="#lv010-at24c02简介" aria-label="Permalink to &quot;LV010-AT24C02简介&quot;">​</a></h1><h2 id="一、eeprom简介" tabindex="-1">一、EEPROM简介 <a class="header-anchor" href="#一、eeprom简介" aria-label="Permalink to &quot;一、EEPROM简介&quot;">​</a></h2><p>EEPROM (Electrically Erasable Programmable read only memory)是指带电可擦可编程只读存储器。是一种掉电后数据不丢失的存储芯片。 EEPROM 可以在电脑上或专用设备上擦除已有信息，重新编程。一般用在即插即用。</p><p>我们这一节的笔记主要是关于AT24C02的使用，它是一个串行电可擦除和可编程只读存储器(EEPROM)，总容量是256（2K/8)个字节，通过IIC通信。它是 <a href="https://www.microchip.com/en-us/tools-resources/search-discover/atmel-start" target="_blank" rel="noreferrer">Atmel</a> 公司的一款芯片，我们我使用的战舰V3的开发板上时AT24C02BN，我们可以在这里找到它的数据手册：<a href="https://ww1.microchip.com/downloads/en/DeviceDoc/doc5126.pdf" target="_blank" rel="noreferrer">AT24C01A/02/04/08/16 (microchip.com)</a>。</p><h2 id="二、at24c02功能" tabindex="-1">二、AT24C02功能 <a class="header-anchor" href="#二、at24c02功能" aria-label="Permalink to &quot;二、AT24C02功能&quot;">​</a></h2><h3 id="_1-框图" tabindex="-1">1. 框图 <a class="header-anchor" href="#_1-框图" aria-label="Permalink to &quot;1. 框图&quot;">​</a></h3><p>我们可以看 <a href="https://ww1.microchip.com/downloads/en/DeviceDoc/doc5126.pdf" target="_blank" rel="noreferrer">AT24C01A/02/04/08/16 (microchip.com)</a></p><img src="'+r+'" alt="image-20230507122145166" style="zoom:80%;"><p>引脚功能描述如下：</p><table tabindex="0"><thead><tr><th>引脚</th><th>说明</th></tr></thead><tbody><tr><td>A0~A2</td><td>Address Input</td></tr><tr><td>SDA</td><td>Serial Data</td></tr><tr><td>SCL</td><td>Serial Clock Input</td></tr><tr><td>WP</td><td>Write Protect</td></tr><tr><td>VCC</td><td>Supply Voltage(VCC = 1.8V to 5.5V)</td></tr><tr><td>GND</td><td>Ground</td></tr></tbody></table><h3 id="_2-设备地址" tabindex="-1">2. 设备地址 <a class="header-anchor" href="#_2-设备地址" aria-label="Permalink to &quot;2. 设备地址&quot;">​</a></h3><p>我们知道I2C总线是通过设备地址来区分不同的设备，我们使用的AT24C02有三根地址线，它的地址是这样的：</p><img src="'+l+'" alt="image-20230507125856205" style="zoom:80%;"><p>A0~A2可以接GND（代表0）也可以接VCC（代表1），这样根据A0~A2的接线的不同，可以有不同的地址，比如我们把A0~A2全接地，那么设备地址就是1010000x。（我们可以看 <a href="https://ww1.microchip.com/downloads/en/DeviceDoc/doc5126.pdf" target="_blank" rel="noreferrer">AT24C01A/02/04/08/16 (microchip.com)</a> 的 6. Device Addressing）</p><p>那么当我们要读数据的时候，发送的地址就是10100001 = 0xA1，当我们要写数据的时候发送的地址就是10100000 = 0xA0。</p><h3 id="_3-多少页" tabindex="-1">3. 多少页？ <a class="header-anchor" href="#_3-多少页" aria-label="Permalink to &quot;3. 多少页？&quot;">​</a></h3><p>我们需要知道的一些信息：</p><div class="language-c vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">AT24C02 一共是 </span><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;">2Kb</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2048</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">/</span><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;">8B</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;"> 256B</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>我们看芯片手册有这么一句： 8-byte Page (2K) Write Modes，也就是说，这个256B按照8字节一页的方式，被分为32页：</p><div class="language-c vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">AT24C02 一共是 </span><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;">256B</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">/</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">8</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 页</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><h2 id="三、读写数据" tabindex="-1">三、读写数据 <a class="header-anchor" href="#三、读写数据" aria-label="Permalink to &quot;三、读写数据&quot;">​</a></h2><h3 id="_1-写操作" tabindex="-1">1. 写操作 <a class="header-anchor" href="#_1-写操作" aria-label="Permalink to &quot;1. 写操作&quot;">​</a></h3><h4 id="_1-1-byte-write" tabindex="-1">1.1 BYTE WRITE <a class="header-anchor" href="#_1-1-byte-write" aria-label="Permalink to &quot;1.1 BYTE WRITE&quot;">​</a></h4><img src="'+d+'" alt="image-20230507131203330" style="zoom:50%;"><h4 id="_1-2-page-write" tabindex="-1">1.2 PAGE WRITE <a class="header-anchor" href="#_1-2-page-write" aria-label="Permalink to &quot;1.2 PAGE WRITE&quot;">​</a></h4><img src="'+n+'" alt="image-20230507131219435" style="zoom:50%;"><h3 id="_2-读操作" tabindex="-1">2. 读操作 <a class="header-anchor" href="#_2-读操作" aria-label="Permalink to &quot;2. 读操作&quot;">​</a></h3><h4 id="_2-1-current-address-read" tabindex="-1">2.1 CURRENT ADDRESS READ <a class="header-anchor" href="#_2-1-current-address-read" aria-label="Permalink to &quot;2.1 CURRENT ADDRESS READ&quot;">​</a></h4><img src="'+o+'" alt="image-20230507131440446" style="zoom:50%;"><h4 id="_2-2-random-read" tabindex="-1">2.2 RANDOM READ <a class="header-anchor" href="#_2-2-random-read" aria-label="Permalink to &quot;2.2 RANDOM READ&quot;">​</a></h4><img src="'+c+'" alt="image-20230507131453955" style="zoom:50%;"><h4 id="_2-3-sequential-read" tabindex="-1">2.3 SEQUENTIAL READ <a class="header-anchor" href="#_2-3-sequential-read" aria-label="Permalink to &quot;2.3 SEQUENTIAL READ&quot;">​</a></h4><img src="'+h+'" alt="image-20230507131505419" style="zoom:50%;"><h3 id="_3-怎么找到要读写的位置" tabindex="-1">3. 怎么找到要读写的位置？ <a class="header-anchor" href="#_3-怎么找到要读写的位置" aria-label="Permalink to &quot;3. 怎么找到要读写的位置？&quot;">​</a></h3><p>上边是读写操作的过程，那么我们在实际读写过程中，怎么确定我们要往那个地址写数据呢？AT24C02一共是2Kbit，也就是256x8bit，也就是一共256页，每一页是1字节（8位），地址在实际读写的过程中是这样的：</p><table tabindex="0"><thead><tr><th style="text-align:center;">地址</th><th style="text-align:center;">数据</th></tr></thead><tbody><tr><td style="text-align:center;">0x00</td><td style="text-align:center;">xxxx xxxx</td></tr><tr><td style="text-align:center;">0x01</td><td style="text-align:center;">xxxx xxxx</td></tr><tr><td style="text-align:center;">0x02</td><td style="text-align:center;">xxxx xxxx</td></tr><tr><td style="text-align:center;">......</td><td style="text-align:center;">......</td></tr><tr><td style="text-align:center;">0xFF</td><td style="text-align:center;">xxxx xxxx</td></tr></tbody></table>',36)])])}const y=a(p,[["render",m]]);export{A as __pageData,y as default};
