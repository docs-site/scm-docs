import{_ as p,C as r,c as d,o as k,j as i,b0 as t,a,G as l,w as e}from"./chunks/framework.C5ev1SXp.js";const o="/scm-docs/assets/image-20230515230445906.CDgOs1P2.png",M=JSON.parse('{"title":"LV010-内存管理","description":null,"frontmatter":{"title":"LV010-内存管理","date":"2025-10-08T09:57:15.000Z","icon":"famicons:logo-markdown","permalink":"/sdoc/basic/stm32memory/126b0e24d5e326e3a7296e85","index":true,"tags":null,"categories":null,"copyright":false,"keywords":null,"cover":null,"comments":null,"mathjax":null,"top":null,"description":null,"tdoc":{"detailDate":"2025-10-08T09:57:15.622Z","fulluuid":"3a7296e85ae54af393dd0790947698ce","useduuid":"3a7296e85"}},"headers":[],"relativePath":"sdoc/basic/stm32memory/126b0e24d5e326e3a7296e85.md","filePath":"sdoc/10-基础篇/60-STM32的内存/LV010-内存管理.md","lastUpdated":1758811394000}'),h={name:"sdoc/basic/stm32memory/126b0e24d5e326e3a7296e85.md"},m={id:"一、内存管理简介",tabindex:"-1"},u={id:"_1-什么是内存管理",tabindex:"-1"},b={id:"_2-两个函数",tabindex:"-1"},g={id:"_2-1-malloc",tabindex:"-1"},A={id:"_2-2-free",tabindex:"-1"},y={id:"二、分布式内存管理",tabindex:"-1"},f={id:"_1-基本原理",tabindex:"-1"},E={id:"_2-分配原理",tabindex:"-1"},D={id:"_3-释放原理",tabindex:"-1"},F={id:"三、函数设计",tabindex:"-1"},v={id:"_1-内存管理控制结构体",tabindex:"-1"},z={id:"_2-其他函数",tabindex:"-1"};function T(x,s,_,C,P,S){const n=r("font");return k(),d("div",null,[s[36]||(s[36]=i("h1",{id:"lv010-内存管理",tabindex:"-1"},[a("LV010-内存管理 "),i("a",{class:"header-anchor",href:"#lv010-内存管理","aria-label":'Permalink to "LV010-内存管理"'},"​")],-1)),s[37]||(s[37]=i("p",null,"我们学习了使用 STM32F1 驱动外部 SRAM，以扩展 STM32F1 的内存，加上STM32F1 本身自带的 64K 字节内存，我们可供使用的内存还是比较多的。如果我们所用的内存都像上一节的 testsram 那样，定义一个数组来使用，显然不是一个好办法。后来在使用Flash做Bootloader实验的时候，就无法在原有工程中定义一个55KB的数组，然后 lcd做字模缩放的时候，数组也是预先定义好的，直接就16KB，再加上一些其他的，STM32内部Flash一共就64KB，直接被我占满，sct文件中定义了SRAM的长度，导致编译都无法通过，所以动态的去管理内存就很有必要了。",-1)),i("h1",m,[l(n,{size:"3"},{default:e(()=>[...s[0]||(s[0]=[a("一、内存管理简介",-1)])]),_:1}),s[1]||(s[1]=a()),s[2]||(s[2]=i("a",{class:"header-anchor",href:"#一、内存管理简介","aria-label":'Permalink to "<font size=3>一、内存管理简介</font>"'},"​",-1))]),i("h2",u,[l(n,{size:"3"},{default:e(()=>[...s[3]||(s[3]=[a("1. 什么是内存管理",-1)])]),_:1}),s[4]||(s[4]=a()),s[5]||(s[5]=i("a",{class:"header-anchor",href:"#_1-什么是内存管理","aria-label":'Permalink to "<font size=3>1. 什么是内存管理</font>"'},"​",-1))]),s[38]||(s[38]=i("p",null,[a("内存管理，是指软件运行时对计算机内存资源的分配和使用的技术。其"),i("strong",null,"最主要的目的"),a("是如何高效，快速的分配，并且在适当的时候释放和回收内存资源。 内存管理的实现方法有很多种，他们其实最终都是要实现 2 个函数： malloc 和 free； malloc 函数用于内存申请， free 函数用于内存释放。")],-1)),i("h2",b,[l(n,{size:"3"},{default:e(()=>[...s[6]||(s[6]=[a("2. 两个函数",-1)])]),_:1}),s[7]||(s[7]=a()),s[8]||(s[8]=i("a",{class:"header-anchor",href:"#_2-两个函数","aria-label":'Permalink to "<font size=3>2. 两个函数</font>"'},"​",-1))]),s[39]||(s[39]=i("p",null,"我们不详细去挖malloc和free是如何申请和释放内存的，这里只学习函数的用法。",-1)),i("h3",g,[l(n,{size:"3"},{default:e(()=>[...s[9]||(s[9]=[a("2.1 malloc()",-1)])]),_:1}),s[10]||(s[10]=a()),s[11]||(s[11]=i("a",{class:"header-anchor",href:"#_2-1-malloc","aria-label":'Permalink to "<font size=3>2.1 malloc()</font>"'},"​",-1))]),s[40]||(s[40]=t(`<div class="language-c vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#include</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &lt;stdlib.h&gt;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">extern</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> _ARMABI </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">malloc</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">size_t</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> /*size*/</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   /*</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    * allocates space for an object whose size is specified by &#39;size&#39; and whose</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    * value is indeterminate.</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    * Returns: either a null pointer or a pointer to the allocated space.</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    */</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>**【函数说明】**申请指定字节数的内存空间。</p><p><strong>【函数参数】</strong></p><ul><li>size_t ：函数的声明中，只有形参类型，我们在keil中追踪这个类型，会发现它其实就是 unsigned int 类型，表示我们要申请的内存空间的字节数。</li></ul><p><strong>【注意事项】</strong></p><p>（1）申请到的内存空间不会自动初始化，我们需要自己去初始化；</p><p>（2）函数返回值为void *类型，我们需要做强制类型转换，转换为我们需要的数据类型的指针类型。</p>`,7)),i("h3",A,[l(n,{size:"3"},{default:e(()=>[...s[12]||(s[12]=[a("2.2 free()",-1)])]),_:1}),s[13]||(s[13]=a()),s[14]||(s[14]=i("a",{class:"header-anchor",href:"#_2-2-free","aria-label":'Permalink to "<font size=3>2.2 free()</font>"'},"​",-1))]),s[41]||(s[41]=t(`<div class="language-c vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#include</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &lt;stdlib.h&gt;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">extern</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> _ARMABI </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> free</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> /*ptr*/</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   /*</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    * causes the space pointed to by ptr to be deallocated (i.e., made</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    * available for further allocation). If ptr is a null pointer, no action</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    * occurs. Otherwise, if ptr does not match a pointer earlier returned by</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    * calloc, malloc or realloc or if the space has been deallocated by a call</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    * to free or realloc, the behaviour is undefined.</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    */</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>**【函数说明】**释放通过malloc申请的内存空间。</p><p><strong>【函数参数】</strong></p><ul><li>void ：函数的声明中，只有形参类型，这是一个void *类型，表示要释放的内存空间的首地址。</li></ul><p><strong>【注意事项】</strong></p>`,5)),i("h1",y,[l(n,{size:"3"},{default:e(()=>[...s[15]||(s[15]=[a("二、分布式内存管理",-1)])]),_:1}),s[16]||(s[16]=a()),s[17]||(s[17]=i("a",{class:"header-anchor",href:"#二、分布式内存管理","aria-label":'Permalink to "<font size=3>二、分布式内存管理</font>"'},"​",-1))]),s[42]||(s[42]=i("p",null,"我们来学习一种比较简单的办法来实现：分块式内存管理。",-1)),i("h2",f,[l(n,{size:"3"},{default:e(()=>[...s[18]||(s[18]=[a("1. 基本原理",-1)])]),_:1}),s[19]||(s[19]=a()),s[20]||(s[20]=i("a",{class:"header-anchor",href:"#_1-基本原理","aria-label":'Permalink to "<font size=3>1. 基本原理</font>"'},"​",-1))]),s[43]||(s[43]=i("img",{src:o,alt:"image-20230515230445906",style:{zoom:"80%"}},null,-1)),s[44]||(s[44]=i("p",null,[a("分块式内存管理由"),i("strong",null,"内存池"),a("和"),i("strong",null,"内存管理表"),a("两部分组成。内存池被等分为n块，对应的内存管理表，大小也为n，内存管理表的每一个项对应内存池的一块内存。")],-1)),s[45]||(s[45]=i("p",null,"内存管理表的项值代表的意义：当该项值为0的时候，代表对应的内存块未被占用，当该项值非零的时候，代表该项对应的内存块已经被占用，其数值则代表被连续占用的内存块数。比如某项值为10，那么说明包括本项对应的内存块在内，总共分配了10个内存块给外部的某个指针。",-1)),s[46]||(s[46]=i("p",null,"内存分配方向：是从顶到底的分配方向。即首先从最末端开始找空内存。当内存管理刚初始化的时候，内存管理表全部清零，表示没有任何内存块被占用。",-1)),i("h2",E,[l(n,{size:"3"},{default:e(()=>[...s[21]||(s[21]=[a("2. 分配原理",-1)])]),_:1}),s[22]||(s[22]=a()),s[23]||(s[23]=i("a",{class:"header-anchor",href:"#_2-分配原理","aria-label":'Permalink to "<font size=3>2. 分配原理</font>"'},"​",-1))]),s[47]||(s[47]=i("p",null,"当指针p调用malloc申请内存的时候，先判断p要分配的内存块数（m），然后从第n项开始，向下查找，直到找到m块连续的空内存块（即对应内存管理表项为0），然后将这m个内存管理表项的值都设置为m（标记被占用），最后，把最后的这个空内存块的地址返回指针p，完成一次分配。注意，如果当内存不够的时候（找到最后也没找到连续的m块空闲内存），则返回NULL给p，表示分配失败。",-1)),i("h2",D,[l(n,{size:"3"},{default:e(()=>[...s[24]||(s[24]=[a("3. 释放原理",-1)])]),_:1}),s[25]||(s[25]=a()),s[26]||(s[26]=i("a",{class:"header-anchor",href:"#_3-释放原理","aria-label":'Permalink to "<font size=3>3. 释放原理</font>"'},"​",-1))]),s[48]||(s[48]=i("p",null,"当指针p申请的内存用完，需要释放的时候，调用free函数实现。free函数先判断p指向的内存地址所对应的内存块，然后找到对应的内存管理表项目，得到p所占用的内存块数目m（内存管理表项目的值就是所分配内存块的数目），将这m个内存管理表项目的值都清零，标记释放，完成一次内存释放。",-1)),i("h1",F,[l(n,{size:"3"},{default:e(()=>[...s[27]||(s[27]=[a("三、函数设计",-1)])]),_:1}),s[28]||(s[28]=a()),s[29]||(s[29]=i("a",{class:"header-anchor",href:"#三、函数设计","aria-label":'Permalink to "<font size=3>三、函数设计</font>"'},"​",-1))]),i("h2",v,[l(n,{size:"3"},{default:e(()=>[...s[30]||(s[30]=[a("1. 内存管理控制结构体",-1)])]),_:1}),s[31]||(s[31]=a()),s[32]||(s[32]=i("a",{class:"header-anchor",href:"#_1-内存管理控制结构体","aria-label":'Permalink to "<font size=3>1. 内存管理控制结构体</font>"'},"​",-1))]),s[49]||(s[49]=t(`<div class="language-c vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 内存管理控制器</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">typedef</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> __malloc_dev</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    int8_t</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">init)(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">uint8_t</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">       // 初始化</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    uint8_t</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">perused)(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">uint8_t</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 内存使用率</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    uint8_t</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">membase</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[SRAMBANK];</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 内存池 管理SRAMBANK个区域的内存</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    uint16_t</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">memmap</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[SRAMBANK];</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 内存管理状态表</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    uint8_t</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> memrdy</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[SRAMBANK];</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 内存管理是否就绪</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}FUNC_MEM;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div>`,1)),i("h2",z,[l(n,{size:"3"},{default:e(()=>[...s[33]||(s[33]=[a("2. 其他函数",-1)])]),_:1}),s[34]||(s[34]=a()),s[35]||(s[35]=i("a",{class:"header-anchor",href:"#_2-其他函数","aria-label":'Permalink to "<font size=3>2. 其他函数</font>"'},"​",-1))]),s[50]||(s[50]=i("p",null,[a("其他的那些函数这里就没必要写了，可以看这里："),i("a",{href:"https://gitee.com/embedded-devs/scm-dev/tree/master/40-MEMORY/20-mem-mangement/Drivers/Middlewares/MALLOC",target:"_blank",rel:"noreferrer"},"scm-dev: MALLOC")],-1))])}const V=p(h,[["render",T]]);export{M as __pageData,V as default};
