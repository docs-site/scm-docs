import{_ as t,c as n,o as l,b0 as h}from"./chunks/framework.C5ev1SXp.js";const p="/scm-docs/assets/image-20230506194638996.UXm-MPiV.png",e="/scm-docs/assets/image-20230506195402557.DlVZlZfB.png",i="/scm-docs/assets/image-20230506194933625.DGUU8OJA.png",a="/scm-docs/assets/image-20230506195152880.BIi6YUL4.png",k="/scm-docs/assets/image-20230506195233716.CEZAyRnz.png",r="/scm-docs/assets/image-20230506195554329.ep3ZUgo3.png",d="/scm-docs/assets/image-20230506195649606.Bnjyhpg-.png",g="/scm-docs/assets/image-20230506201000094.CDvcNTs1.png",o="/scm-docs/assets/image-20230506201208372.BDGdLwko.png",F="/scm-docs/assets/image-20230506201252943.BTHYS26o.png",c="/scm-docs/assets/image-20230506201333734.mPwHlQrG.png",E="/scm-docs/assets/image-20230506201402578.D0g5N_ng.png",y="/scm-docs/assets/image-20230506201525794.BNE4-tPV.png",m="/scm-docs/assets/image-20230506201552944.G9ia3ufE.png",A="/scm-docs/assets/image-20230506203822570.Dlt6edsg.png",b="/scm-docs/assets/image-20230506203904832.AbsoUchI.png",f=JSON.parse('{"title":"LV035-CortexM3存储器系统","description":null,"frontmatter":{"title":"LV035-CortexM3存储器系统","date":"2025-09-18T07:57:02.000Z","icon":"famicons:logo-markdown","permalink":"/sdoc/basic/overview/126b08c73d361161792b640a","index":true,"tags":null,"categories":null,"copyright":false,"keywords":null,"cover":null,"comments":null,"mathjax":null,"top":null,"description":null,"tdoc":{"detailDate":"2025-09-18T07:57:02.278Z","fulluuid":"1792b640ad2b40c1a34cc0ea4da24ed9","useduuid":"1792b640a"}},"headers":[],"relativePath":"sdoc/basic/overview/126b08c73d361161792b640a.md","filePath":"sdoc/10-基础篇/01-概述/LV035-CortexM3存储器系统.md","lastUpdated":1758153691000}'),u={name:"sdoc/basic/overview/126b08c73d361161792b640a.md"};function C(D,s,_,x,B,M){return l(),n("div",null,[...s[0]||(s[0]=[h('<h1 id="lv035-cortexm3存储器系统" tabindex="-1">LV035-CortexM3存储器系统 <a class="header-anchor" href="#lv035-cortexm3存储器系统" aria-label="Permalink to &quot;LV035-CortexM3存储器系统&quot;">​</a></h1><p>本篇笔记主要来自于《<a href="https://picture.iczhiku.com/resource/upload/6820519db1f84e7faaf51c573c48e013.pdf" target="_blank" rel="noreferrer">Cortex-M3 权威指南</a>》的第五章存储器系统。其实有一部分概念在后边一篇笔记中才有所体现，比如什么是寄存器？。</p><h2 id="一、存储器映射" tabindex="-1">一、存储器映射 <a class="header-anchor" href="#一、存储器映射" aria-label="Permalink to &quot;一、存储器映射&quot;">​</a></h2><p>CM3 只有一个单一固定的存储器映射。这一点极大地方便了软件在各种 CM3 单片机间的移植。举个简单的例子，各款 CM3 单片机的 NVIC 和 MPU 都在相同的位置布设寄存器，使得它们变得通用。尽管如此， CM3 定出的条条框框是粗线条的，它依然允许芯片制造商灵活地分配存储器空间，以制造出各具特色的单片机产品。存储空间的一些位置用于调试组件等私有外设，这个地址段被称为“ 私有外设区”。私有外设区的组件包括：</p><p>（1）闪存地址重载及断点单元(FPB)</p><p>（2）数据观察点单元(DWT)</p><p>（3）指令跟踪宏单元(ITM)</p><p>（4）嵌入式跟踪宏单元(ETM)</p><p>（5）跟踪端口接口单元(TPIU)</p><p>（6）ROM 表</p><h3 id="_1-预定义的存储器映射" tabindex="-1">1. 预定义的存储器映射 <a class="header-anchor" href="#_1-预定义的存储器映射" aria-label="Permalink to &quot;1. 预定义的存储器映射&quot;">​</a></h3><p>Cortex-M3是32位的单片机，因此其PC指针可以指向2^32=4G的地址空间，也就是图中的 0x00000000到0xFFFFFFFF的区间，也就是将程序存储器、数据存储器、寄存器和输入输出端口被组织在同一个4GB的线性地址空间内，数据字节以小端格式存放在存储器中。Cortex-M3 预定义的存储器映射如下：</p><img src="'+p+'" alt="image-20230506194638996" style="zoom:67%;"><p>这个存储器映射只是个粗线条的模板，半导体厂家会提供更展开的图示，来表明芯片中片上外设的具体分布， RAM 与 ROM 的容量和位置信息。</p><h3 id="_2-代码区域512m" tabindex="-1">2. 代码区域512M <a class="header-anchor" href="#_2-代码区域512m" aria-label="Permalink to &quot;2. 代码区域512M&quot;">​</a></h3><p>CM3 的地址空间是 4GB, 程序可以在代码区，内部 SRAM 区以及外部 RAM 区中执行。但是因为指令总线与数据总线是分开的， 最理想的是把程序放到代码区， 从而使取指和数据访问各自使用自己的总线，并行不悖。</p><img src="'+e+'" alt="image-20230506195402557" style="zoom:33%;"><h3 id="_3-内部sram区域512m" tabindex="-1">3. 内部SRAM区域512M <a class="header-anchor" href="#_3-内部sram区域512m" aria-label="Permalink to &quot;3. 内部SRAM区域512M&quot;">​</a></h3><p>内部 SRAM 区的大小是 512MB，用于让芯片制造商连接片上的 SRAM，这个区通过系统总线来访问。在这个区的下部，有一个 1MB 的位带区：</p><img src="'+i+'" alt="image-20230506194933625" style="zoom:33%;"><p>该位带区还有一个对应的 32MB 的“位带别名(alias)区”，容纳了 8M 个“位变量”（对比 8051 的只有 128 个位）。位带区对应的是最低的 1MB 地址范围，而位带别名区里面的每个字对应位带区的一个比特。位带操作只适用于数据访问，不适用于取指。通过位带的功能，可以把多个布尔型数据打包在单一的字中，却依然可以从位带别名区中，像访问普通内存一样地使用它们。位带别名区中的访问操作是原子的，消灭了传统的“读－改－写”三步曲。位带操作的细节后边再说。</p><h3 id="_4-片上外设区域-512m" tabindex="-1">4. 片上外设区域 512M <a class="header-anchor" href="#_4-片上外设区域-512m" aria-label="Permalink to &quot;4. 片上外设区域 512M&quot;">​</a></h3><p>地址空间的另一个 512MB 范围由片上外设（的寄存器）使用。这个区中也有一条 32MB的位带别名，以便于快捷地访问外设寄存器。例如，可以方便地访问各种控制位和状态位。要注意的是，外设内不允许执行指令。</p><img src="'+a+'" alt="image-20230506195152880" style="zoom:33%;"><h3 id="_5-两个1gb" tabindex="-1">5. 两个1GB <a class="header-anchor" href="#_5-两个1gb" aria-label="Permalink to &quot;5. 两个1GB&quot;">​</a></h3><img src="'+k+'" alt="image-20230506195233716" style="zoom:33%;"><p>这两个 1GB 的范围，分别用于连接外部 RAM 和外部设备，它们之中没有位带。两者的区别在于外部 RAM 区允许执行指令，而外部设备区则不允许。</p><h3 id="_6-最后的512m" tabindex="-1">6. 最后的512M <a class="header-anchor" href="#_6-最后的512m" aria-label="Permalink to &quot;6. 最后的512M&quot;">​</a></h3><p>最后还剩下 0.5GB 的隐秘地带， CM3 内核的闺房就在这里面，包括了系统级组件，内部私有外设总线 s，外部私有外设总线 s，以及由提供者定义的系统外设。</p><img src="'+r+'" alt="image-20230506195554329" style="zoom:50%;"><p>私有外设总线有两条：</p><ul><li><p>AHB 私有外设总线，只用于 CM3 内部的 AHB 外设，它们是： NVIC, FPB, DWT 和 ITM。</p></li><li><p>APB 私有外设总线，既用于 CM3 内部的 APB 设备，也用于外部设备（这里的“外部”是对内核而言）。 CM3 允许器件制造商再添加一些片上 APB 外设到 APB 私有总线上，它们通过 ABP 接口来访问。</p></li></ul><p>NVIC 所处的区域叫做“系统控制空间（ SCS）”，在 SCS 里的还有 SysTick、 MPU 以及代码调试控制所用的寄存器：</p><img src="'+d+'" alt="image-20230506195649606" style="zoom:50%;"><p>最后，未用的提供商指定区也通过系统总线来访问，但是不允许在其中执行指令。CM3 中的 MPU 是选配的，由芯片制造商决定是否配上。</p><h2 id="二、存储器访问属性" tabindex="-1">二、存储器访问属性 <a class="header-anchor" href="#二、存储器访问属性" aria-label="Permalink to &quot;二、存储器访问属性&quot;">​</a></h2><p>CM3 在定义了存储器映射之外，还为存储器的访问规定了 4 种属性，分别是： （1）可否缓冲(Bufferable)</p><p>（2）可否缓存(Cacheable)</p><p>（3）可否执行(Executable)</p><p>（4）可否共享(Sharable)</p><p>如果配了 MPU，则可以通过它配置不同的存储区，并且覆盖缺省的访问属性。 CM3 片内没有配备缓存，也没有缓存控制器，但是允许在外部添加缓存。通常，如果提供了外部内存，芯片制造商还要附加一个内存控制器，它可以根据可否缓存的设置，来管理对片内和片外 RAM 的访问操作。</p><p>地址空间可以通过另一种方式分为 8 个 512MB 等份：</p><p>（1）代码区（ 0x0000_0000‐ 0x1FFF_FFFF）。该区是可以执行指令的，缓存属性为 WT（“写通”，Write Through），即不可以缓存。此区亦可写数据。在此区上的数据操作是通过数据总线接口的（读数据使用 D‐Code，写数据使用 System），且在此区上的写操作是缓冲的。</p><p>（2）SRAM 区（ 0x2000_0000 – 0x3FFF_FFFF）。此区用于片内 SRAM，写操作是缓冲的，并且可以选择 WB‐WA(Write Back, Write Allocated)缓存属性。此区亦可以执行指令，以允许把代码拷贝到内存中执行——常用于固件升级等维护工作。</p><p>（3）片上外设区(0x4000_0000 – 0x5FFF_FFFF)。该区用于片上外设，因此是不可缓存的，也不可以在此区执行指令（这也称为 eXecute Never, XN。 ARM 的参考手册大量使用此术语）。</p><p>（4）外部 RAM 区的前半段（ 0x6000_0000 ‐ 0x7FFF_FFFF）。该区用于片外 RAM，可缓存（缓存属性为 WB‐WA），并且可以执行指令。</p><p>（5）外部RAM区的后半段(0x8000_0000 - 0x9FFF_FFFF)。除了不可缓存(WT)外，同前半段。</p><p>（6）外部外设区的前半段(0xA000_0000 - 0xBFFF_FFFF)。用于片外外设的寄存器，也用于多核系统中的共享内存（需要严格按顺序操作，即不可缓冲)。该区也是个不可执行区。</p><p>（7）外部外设区的后半段(0xC000_0000 - 0xDFFF_FFFF)。目前与前半段的功能完全一致。</p><p>（8）系统区(0xE000_0000 - 0xFFFF_FFFF)。此区是私有外设和供应商指定功能区。此区不可执行代码。系统区涉及到很多关键部位，因此访问都是严格序列化的(不可缓存，不可缓冲)。而供应商指定功能区则是可以缓存和缓冲的。</p><blockquote><p>写通，写回，与写时申请：</p><p>写回(Write Back)：写入的数据先逗留在缓存中，待到必要时再落实到最终目的地，这也是cache 的最基本职能，用于改善数据传送的效率。</p><p>写通(Write Through)：写操作“穿透”中途的缓存，直接落入最终的目的地中。可见，写通操作架空了cache，但它使写操作的结果立即生效。这常用于和片上外设或其它处理器共享的内存中，如显卡的显存，片上外设寄存器，以及双核系统中的共享内存。写通操作和C中的“volatile&quot;”有密切的联系。</p><p>写时申请(Write Allocate)：译者也不太清楚啦~</p></blockquote><h2 id="三、存储器的缺省访问许可" tabindex="-1">三、存储器的缺省访问许可 <a class="header-anchor" href="#三、存储器的缺省访问许可" aria-label="Permalink to &quot;三、存储器的缺省访问许可&quot;">​</a></h2><p>CM3有一个缺省的存储访问许可，它能防止使用户代码访问系统控制存储空间，保护NVIC、MPU等关键部件。缺省访问许可在下列条件时生效：</p><p>（1）没有配备MPU</p><p>（2）配备了MPU，但是MPU被除能</p><p>如果启用了MPU，则 MPU可以在地址空间中划出若干个regions，并为不同的 region规定不同的访问许可权限。缺省的存储器访问许可权限如下表：</p><img src="'+g+'" alt="image-20230506201000094" style="zoom:50%;"><p>当一个用户级访问被阻止时，会立即产生一个总线fault。</p><h2 id="四、位带操作" tabindex="-1">四、位带操作 <a class="header-anchor" href="#四、位带操作" aria-label="Permalink to &quot;四、位带操作&quot;">​</a></h2><h3 id="_1-位带区与位带别名区关系" tabindex="-1">1. 位带区与位带别名区关系 <a class="header-anchor" href="#_1-位带区与位带别名区关系" aria-label="Permalink to &quot;1. 位带区与位带别名区关系&quot;">​</a></h3><p>支持了位带操作后，可以使用普通的加载/存储指令来对单一的比特进行读写。在CM3中，有两个区中实现了位带，其中一个是 SRAM 区的最低 1MB 范围 第二个则是片内外设区的最低 1MB 范围。这两个区中的地址除了可以像普通的 RAM 一样使用外，它们还都有自己的“位带别名区”，位带别名区把每个比特膨胀成一个 32 位的字。当通过位带别名区访问这些字时，就可以达到访问原始比特的目的 。</p><ul><li>位带区与位带别名区的膨胀关系图</li></ul><img src="'+o+'" alt="image-20230506201208372" style="zoom:50%;"><ul><li>下图从另一个侧面演示比特的膨胀对应关系</li></ul><img src="'+F+'" alt="image-20230506201252943" style="zoom:50%;"><h3 id="_2-位带操作举例" tabindex="-1">2. 位带操作举例 <a class="header-anchor" href="#_2-位带操作举例" aria-label="Permalink to &quot;2. 位带操作举例&quot;">​</a></h3><h4 id="_2-1-位带写操作" tabindex="-1">2.1 位带写操作 <a class="header-anchor" href="#_2-1-位带写操作" aria-label="Permalink to &quot;2.1 位带写操作&quot;">​</a></h4><p>举例：我们要是想要设置地址 0x2000_0000 中的比特 2，则使用位带操作的设置过程如下图所示：</p><img src="'+c+'" alt="image-20230506201333734" style="zoom:55%;"><p>对应的汇编如下：</p><img src="'+E+'" alt="image-20230506201402578" style="zoom:67%;"><h4 id="_2-2-位带读操作" tabindex="-1">2.2 位带读操作 <a class="header-anchor" href="#_2-2-位带读操作" aria-label="Permalink to &quot;2.2 位带读操作&quot;">​</a></h4><p>位带读操作相对简单些</p><img src="'+y+'" alt="image-20230506201525794" style="zoom:67%;"><p>对应的汇编为：</p><img src="'+m+'" alt="image-20230506201552944" style="zoom:67%;"><h3 id="_3-基本原理" tabindex="-1">3. 基本原理 <a class="header-anchor" href="#_3-基本原理" aria-label="Permalink to &quot;3. 基本原理&quot;">​</a></h3><p>位带操作的概念其实多年前就有了， 那还是8051单片机开创的先河。CM3 使用如下术语来表示位带存储的相关地址 ：</p><ul><li>位带区： 支持位带操作的地址区</li><li>位带别名： 对别名地址的访问最终作用到位带区的访问上（注意：这中间有一个地址映射过程）</li></ul><p>在位带区中，每个比特都映射到别名地址区的一个字——这是只有LSB有效的字。当一个别名地址被访问时，会先把该地址变换成位带地址。对于读操作，读取位带地址中的一个字，再把需要的位右移到LSB，并把 LSB返回。对于写操作，把需要写的位左移至对应的位序号处，然后执行一个原子的“读一改一写”过程。支持位带操作的两个内存区的范围是：</p><ul><li>0x2000_0000‐0x200F_FFFF（ SRAM 区中的最低 1MB）</li></ul><img src="'+i+`" alt="image-20230506194933625" style="zoom:33%;"><p>对 SRAM 位带区的某个比特，记它所在字节地址为 A，位序号为n（0≤ n ≤ 7）则该比特位在别名区的地址为：</p><div class="language-c vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// “*4”表示一个字为 4 个字节，“*8”表示一个字节中有 8 个比特。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">AliasAddr </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> 0x</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">22000000</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ((A </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> 0x</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2000000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 8</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> n) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 4</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> 0x</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">22000000</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (A </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> 0x</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">20000000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 32</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> n </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 4</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><ul><li>0x4000_0000‐0x400F_FFFF（片上外设区中的最低 1MB）</li></ul><img src="`+a+`" alt="image-20230506195152880" style="zoom:33%;"><p>对 片上外设区的某个比特，记它所在字节地址为 A，位序号为n（0≤ n ≤ 7）则该比特位在别名区的地址为：</p><div class="language-c vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// “*4”表示一个字为 4 个字节，“*8”表示一个字节中有 8 个比特。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">AliasAddr </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> 0x</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">42000000</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ((A </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> 0x</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">4000000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 8</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> n) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 4</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> 0x</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">42000000</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (A </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> 0x</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">40000000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 32</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> n </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 4</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h3 id="_4-位带别名重映射" tabindex="-1">4. 位带别名重映射 <a class="header-anchor" href="#_4-位带别名重映射" aria-label="Permalink to &quot;4. 位带别名重映射&quot;">​</a></h3><h4 id="_4-1-sram区" tabindex="-1">4.1 SRAM区 <a class="header-anchor" href="#_4-1-sram区" aria-label="Permalink to &quot;4.1 SRAM区&quot;">​</a></h4><table tabindex="0"><thead><tr><th>位带区</th><th>等效别名地址</th></tr></thead><tbody><tr><td>0x2000000.0</td><td>0x2200000.0</td></tr><tr><td>0x2000000.1</td><td>0x2200004.0</td></tr><tr><td>0x2000000.2</td><td>0x2200008.0</td></tr><tr><td>......</td><td>......</td></tr><tr><td>0x2000000.31</td><td>0x220007C.0</td></tr><tr><td>0x2000004.0</td><td>0x2200080.0</td></tr><tr><td>0x2000004.1</td><td>0x2200084.0</td></tr><tr><td>0x2000004.2</td><td>0x2200088.0</td></tr><tr><td>......</td><td>......</td></tr><tr><td>0x200FFFFC.31</td><td>0x23FFFFFC.0</td></tr></tbody></table><h4 id="_4-2-片上外设区" tabindex="-1">4.2 片上外设区 <a class="header-anchor" href="#_4-2-片上外设区" aria-label="Permalink to &quot;4.2 片上外设区&quot;">​</a></h4><table tabindex="0"><thead><tr><th>位带区</th><th>等效别名地址</th></tr></thead><tbody><tr><td>0x4000000.0</td><td>0x4200000.0</td></tr><tr><td>0x4000000.1</td><td>0x4200004.0</td></tr><tr><td>0x4000000.2</td><td>0x4200008.0</td></tr><tr><td>......</td><td>......</td></tr><tr><td>0x4000000.31</td><td>0x420007C.0</td></tr><tr><td>0x4000004.0</td><td>0x4200080.0</td></tr><tr><td>0x4000004.1</td><td>0x4200084.0</td></tr><tr><td>0x4000004.2</td><td>0x4200088.0</td></tr><tr><td>......</td><td>......</td></tr><tr><td>0x400FFFFC.31</td><td>0x43FFFFFC.0</td></tr></tbody></table><h4 id="_4-3-一个实例" tabindex="-1">4.3 一个实例 <a class="header-anchor" href="#_4-3-一个实例" aria-label="Permalink to &quot;4.3 一个实例&quot;">​</a></h4><p>（1）在地址0x20000000处写入0x3355AACC</p><p>（2）读取地址0x22000008。本次读访问将读取0x20000000，并提取比特2，值为1。</p><p>（3）往地址0x22000008处写0。本次操作将被映射成对地址0x20000000的“读一改一写”操作（原子的)，把比特⒉清 0。</p><p>（4）现在再读取0x20000000，将返回0x3355AAC8 ( bit[2]已清零)。</p><p>位带别名区的字只有LSB有意义。另外，在访问位带别名区时，不管使用哪一种长度的数据传送指令(字/半字/字节)，都把地址对齐到字的边界上，否则会产生不可预料的结果。</p><h3 id="_5-位带操作的好处" tabindex="-1">5. 位带操作的好处 <a class="header-anchor" href="#_5-位带操作的好处" aria-label="Permalink to &quot;5. 位带操作的好处&quot;">​</a></h3><p>位带操作有什么优越性呢?最容易想到的就是通过GPIO的管脚来单独控制每盏LED的点亮与熄灭。另一方面,也对操作串行接口器件提供了很大的方便(典型如74HC165，CD4094)。总之位带操作对于硬件I/O密集型的底层程序最有用处了。</p><p>CM3中还有一个称为“bit-bang”的概念，它通常是通过“bit-band”实现的，但是它俩在学术上是两个不同的概念。位带操作还能用来化简跳转的判断。当跳转依据是某个位时，以前必须这样做:（1）读取整个寄存器（2）掩蔽不需要的位（3）比较并跳转。现在只需:（1）从位带别名区读取状态位（2）比较并跳转。使代码更简洁 。</p><p>这只是位带操作优越性的初等体现，位带操作还有一个重要的好处是在多任务中，<strong>用于实现共享资源在任务间的“互锁”访问</strong>。多任务的共享资源必须满足一次只有一个任务访问它——亦即所谓的“原子操作”。以前的读一改一写需要3条指令，导致这中间留有两个能被中断的空当。于是可能会出现如下图所示的紊乱危象:</p><img src="`+A+'" alt="image-20230506203822570" style="zoom:67%;"><p>同样的紊乱危象可以出现在多任务的执行环境中。其实，上图所演示的情况可以看作是多任务的一个特例：主程序是一个任务， ISR 是另一个任务，这两个任务并发执行。</p><p>通过使用 CM3 的位带操作，就可以消灭上例中的紊乱危象。 CM3 把这个“读－改－写”做成一个硬件级别支持的原子操作，不能被中断，如下图：</p><img src="'+b+`" alt="image-20230506203904832" style="zoom:67%;"><h3 id="_6-在c语言中使用位带" tabindex="-1">6. 在C语言中使用位带 <a class="header-anchor" href="#_6-在c语言中使用位带" aria-label="Permalink to &quot;6. 在C语言中使用位带&quot;">​</a></h3><p>不幸的是，在 C 编译器中并没有直接支持位带操作。比如， C 编译器并不知道同一块内存能够使用不同的地址来访问，也不知道对位带别名区的访问只对 LSB 有效。欲在 C 中使用位带操作，最简单的做法就是#define 一个位带别名区的地址。例如：</p><div class="language-c vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#define</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> DEVICE_REG0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      ((</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">volatile</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> unsigned</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> long</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">0x</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">40000000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">))</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#define</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> DEVICE_REG0_BIT0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ((</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">volatile</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> unsigned</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> long</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">0x</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">42000000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">))</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#define</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> DEVICE_REG0_BIT1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ((</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">volatile</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> unsigned</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> long</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">0x</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">42000004</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">))</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">DEVICE_REG0 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> 0x</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AB</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 地址访问寄存器</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">DEVICE_REG0 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">DEVICE_REG0 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">|</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> 0x</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 使用传统方法设置 bit1</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">DEVICE_REG0_BIT1 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> 0x</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">           // 通过位带别名地址设置 bit1</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>为简化位带操作，也可以定义一些宏。比如，我们可以建立一个把”位带地址+位序号“转换成别名地址的宏，再建立一个把别名地址转换成指针类型的宏：</p><div class="language-c vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//把“位带地址＋位序号”转换成别名地址的宏</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#define</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> BITBAND</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">addr</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">bitnum</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) ((addr </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> 0x</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">F0000000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> 0x</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2000000</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ((addr </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> 0x</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">FFFFF</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (bitnum </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">))</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//把该地址转换成一个指针</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#define</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MEM_ADDR</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">addr</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">volatile</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> unsigned</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> long</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) (addr))</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>在此基础上，我们就可以如下改写代码：</p><div class="language-c vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">MEM_ADDR</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(DEVICE_REG0) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> 0x</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AB</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> //使用正常地址访问寄存器</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">MEM_ADDR</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(DEVICE_REGO) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MEM_ADDR</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(DEVICE_REGO) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">|</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> 0x</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 传统做法</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">MEM_ADDR</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">BITBAND</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(DEVICE_REGO, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> 0x</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">            // 使用位带别名地址</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>注意：当使用位带功能时，要访问的变量必须用 volatile 来定义。因为 C 编译器并不知道同一个比特可以有两个地址。所以就要通过volatile，使得编译器每次都如实地把新数值写入存储器，而不再会出于优化的考虑，在中途使用寄存器来操作数据的复本，直到最后才把复本写回（这和 cache的原理是一样的)。</p><blockquote><p>参考资料：</p><p><a href="https://bbs.huaweicloud.com/blogs/375342" target="_blank" rel="noreferrer">STM32的内存管理相关（内存架构，内存管理，map文件分析）-云社区-华为云</a></p></blockquote>`,116)])])}const q=t(u,[["render",C]]);export{f as __pageData,q as default};
