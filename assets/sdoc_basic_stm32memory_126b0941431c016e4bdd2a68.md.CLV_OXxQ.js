import{_ as a,c as o,o as r,b0 as c}from"./chunks/framework.C5ev1SXp.js";const d="/scm-docs/assets/image-20251008084514529.DaG8GhKG.png",t="/scm-docs/assets/image-20251008094745258.DdRtJOUp.png",s="/scm-docs/assets/image-20251008090904612.BxgfKb0W.png",l="/scm-docs/assets/image-20251008094823496.DbhoDD6o.png",f=JSON.parse('{"title":"LV001-STM32内存简介","description":null,"frontmatter":{"title":"LV001-STM32内存简介","date":"2025-09-26T07:26:04.000Z","icon":"famicons:logo-markdown","permalink":"/sdoc/basic/stm32memory/126b0941431c016e4bdd2a68","index":true,"tags":null,"categories":null,"copyright":false,"keywords":null,"cover":null,"comments":null,"mathjax":null,"top":null,"description":null,"tdoc":{"detailDate":"2025-09-26T07:26:04.022Z","fulluuid":"e4bdd2a68030419b91dea7af452724aa","useduuid":"e4bdd2a68"}},"headers":[],"relativePath":"sdoc/basic/stm32memory/126b0941431c016e4bdd2a68.md","filePath":"sdoc/10-基础篇/60-STM32的内存/LV001-STM32内存简介.md","lastUpdated":1758811394000}'),i={name:"sdoc/basic/stm32memory/126b0941431c016e4bdd2a68.md"};function n(m,e,p,b,h,u){return r(),o("div",null,[...e[0]||(e[0]=[c('<h1 id="lv001-stm32内存简介" tabindex="-1">LV001-STM32内存简介 <a class="header-anchor" href="#lv001-stm32内存简介" aria-label="Permalink to &quot;LV001-STM32内存简介&quot;">​</a></h1><p>其实断断续续的，STM32启动文件、启动方式、程序组成、map文件、sct文件、sram、内部flash都大概已经了解过了，这里进行总结，从stm32启动开始，到程序跑起来，这中间究竟是怎么个过程。</p><blockquote><p>测试工程：<a href="https://gitee.com/embedded-devs/scm-dev/tree/master/40-MEMORY/10-free-rtos" target="_blank" rel="noreferrer">scm-dev: 10-free-rtos</a></p></blockquote><h2 id="一、单片机的启动" tabindex="-1">一、单片机的启动 <a class="header-anchor" href="#一、单片机的启动" aria-label="Permalink to &quot;一、单片机的启动&quot;">​</a></h2><img src="'+d+'" alt="image-20251008084514529" style="zoom:50%;"><p>关于存储器映像，可以看 <a href="/scm-docs/sdoc/basic/stm32basic/126b08e6840f3457e72c8780.html">10-基础篇/10-STM32基础/LV045-STM32存储器系统.md</a></p><p>关于启动方式，我们可以看 <a href="/scm-docs/sdoc/basic/stm32setup/126b08e78de70b59cd9ba362.html">10-基础篇/20-STM32的启动/LV005-启动过程.md</a>，单片机根据启动模式选择引脚，可以选择从不同的存储区域启动，当选择不同的模式时，对应区域的起始地址就会被映射到0x0000 0000。</p><h2 id="二、程序存储和运行" tabindex="-1">二、程序存储和运行 <a class="header-anchor" href="#二、程序存储和运行" aria-label="Permalink to &quot;二、程序存储和运行&quot;">​</a></h2><p>直接看下面这张图吧：</p><p><img src="'+t+'" alt="image-20251008094745258"></p><p>参考 <a href="/scm-docs/sdoc/dev-tool/keil/126b08e6a9c4187125e57a5f.html">01-开发工具/01-keil/LV010-程序与编译.md</a>我们知道程序编译完成会有三种属性：</p><table tabindex="0"><thead><tr><th>类别</th><th>包含的存储段</th><th>存储内容示例</th></tr></thead><tbody><tr><td>RO</td><td><code>.text(Code)</code>、<code>.rodata(RO-Data)</code></td><td>- <code>.text</code>：函数代码（如 <code>func()</code>、<code>main()</code> 的指令）- <code>.rodata</code>：只读常量（如 <code>const int globe_const_var = 30</code>）</td></tr><tr><td>RW</td><td><code>.data(RW-Data)</code></td><td>已初始化且非零的全局变量 / 静态变量（如 <code>int globe_var1 = 10</code>、<code>static int static_var1 = 70</code>）</td></tr><tr><td>ZI</td><td><code>.bss(ZI-Data)</code></td><td>未初始化或初始化为 0 的全局变量 / 静态变量（如 <code>int globe_var2</code>、<code>static int static_var2</code>、<code>static int x = 0</code>）</td></tr></tbody></table><p>单片机上电后，会把RW-Data复制到内部SRAM中，上图中，我用了之前的SCT分散加载文件，将内部SRAM一分为二了，但是我们主要是根据map文件进行分析，并不影响最终结论。</p><h2 id="三、freertos相关内存" tabindex="-1">三、FreeRTOS相关内存 <a class="header-anchor" href="#三、freertos相关内存" aria-label="Permalink to &quot;三、FreeRTOS相关内存&quot;">​</a></h2><p><img src="'+t+'" alt="image-20251008094745258"></p><ul><li>问题一：对于带有FreeRTOS系统的程序，FreeRTOS分配的内存都在那里？</li></ul><p>这里我们找到ucHeap这个数组，直接全局搜索：</p><p><img src="'+s+'" alt="image-20251008090904612"></p><p>这个ucHeap是static类型，并且是没有初始化的区域，它将会被定义在.bss段，在map文件中的名称为heap4，它就是FreeRTOS系统堆所占用的空间。</p><ul><li>问题二：FreeRTOS系统中，静态创建任务和动态创建任务，任务占用的是哪里的内存？</li></ul><blockquote><p><strong>任务控制块（TCB）</strong>： 一个数据结构，用于保存任务的状态、优先级、栈指针等信息。</p><p><strong>任务栈（Stack）</strong>： 用于存储任务执行时的局部变量、函数调用地址、中断上下文等。</p></blockquote><p><a href="https://github.com/FreeRTOS/FreeRTOS-Kernel/blob/0030d609a4b99118d9a400340d88c3c3c4816f2b/tasks.c#L1740" target="_blank" rel="noreferrer">FreeRTOS-Kernel/tasks.c - xTaskCreate()</a>是动态创建任务，这个我没有去深究了，问了下DeepSeek，当调用<code>xTaskCreate()</code>时，FreeRTOS内核会<strong>自动</strong>从它管理的堆（Heap）中，为我们申请两块内存用于任务控制块（TCB）和任务栈（Stack）。</p><p><a href="https://github.com/FreeRTOS/FreeRTOS-Kernel/blob/0030d609a4b99118d9a400340d88c3c3c4816f2b/tasks.c#L1331" target="_blank" rel="noreferrer">FreeRTOS-Kernel/tasks.c - xTaskCreateStatic()</a>是静态创建任务，它的内存来源是用户（程序员）预先分配的静态内存，可以是定义的全局变量，将会存在于单片机的**<code>.data</code>段**（已初始化的全局/静态变量）或者**<code>.bss</code>段**（未初始化的全局/静态变量）。也可以是malloc申请的内存，如果使用标准库的<code>malloc</code>申请的话，就位于单片机堆上。</p><h2 id="四、总结" tabindex="-1">四、总结 <a class="header-anchor" href="#四、总结" aria-label="Permalink to &quot;四、总结&quot;">​</a></h2><p><img src="'+l+'" alt="image-20251008094823496"></p><blockquote><p>参考资料：</p><p><a href="https://www.zhihu.com/question/594673950" target="_blank" rel="noreferrer">(8 封私信) freertos为什么要有个动态和静态两种创建任务方式？ - 知乎</a></p></blockquote>',26)])])}const g=a(i,[["render",n]]);export{f as __pageData,g as default};
