import{_ as i,c as a,o as n,b0 as l}from"./chunks/framework.C5ev1SXp.js";const e="/scm-docs/assets/image-20230513214818295.C_hbgz97.png",t="/scm-docs/assets/image-20230513215401849.BVy_HYGI.png",p="/scm-docs/assets/image-20230514073151016.PqJi3H_r.png",h="/scm-docs/assets/image-20230514080259689.9x11DCP5.png",k="/scm-docs/assets/image-20230514080246220.Bb2rz582.png",r="/scm-docs/assets/image-20230514080320055.CExq89jK.png",d="/scm-docs/assets/image-20230514080329214.BLpQT6XG.png",E="/scm-docs/assets/image-20230514080340682.DQHf8ke0.png",c="/scm-docs/assets/image-20230514080618616.B7ccrzV7.png",o="/scm-docs/assets/image-20230602190402837.KzeOK-4i.png",D=JSON.parse('{"title":"LV010-FATFS简介","description":null,"frontmatter":{"title":"LV010-FATFS简介","date":"2025-09-27T10:54:25.000Z","icon":"famicons:logo-markdown","permalink":"/sdoc/advanced-chapter/file-system/126b095105912fc87e8eb3f7","index":true,"tags":null,"categories":null,"copyright":false,"keywords":null,"cover":null,"comments":null,"mathjax":null,"top":null,"description":null,"tdoc":{"detailDate":"2025-09-27T10:54:25.764Z","fulluuid":"87e8eb3f76b14573a4c0856bf2257669","useduuid":"87e8eb3f7"}},"headers":[],"relativePath":"sdoc/advanced-chapter/file-system/126b095105912fc87e8eb3f7.md","filePath":"sdoc/30-进阶篇/01-文件系统/LV010-FATFS简介.md","lastUpdated":1758811394000}'),g={name:"sdoc/advanced-chapter/file-system/126b095105912fc87e8eb3f7.md"};function b(u,s,y,F,m,f){return n(),a("div",null,[...s[0]||(s[0]=[l('<h1 id="lv010-fatfs简介" tabindex="-1">LV010-FATFS简介 <a class="header-anchor" href="#lv010-fatfs简介" aria-label="Permalink to &quot;LV010-FATFS简介&quot;">​</a></h1><h2 id="二、-fatfs简介" tabindex="-1">二、 FatFs简介 <a class="header-anchor" href="#二、-fatfs简介" aria-label="Permalink to &quot;二、 FatFs简介&quot;">​</a></h2><h3 id="_1-fatfs是什么" tabindex="-1">1. FatFs是什么？ <a class="header-anchor" href="#_1-fatfs是什么" aria-label="Permalink to &quot;1. FatFs是什么？&quot;">​</a></h3><p>FATFS 是一个完全免费开源的 FAT 文件系统模块，专门为小型的嵌入式系统而设计。它完全用标准 C 语言编写，所以具有良好的硬件平台独立性，可以移植到 8051、 PIC、 AVR、 SH、Z80、 H8、 ARM 等系列单片机上而只需做简单的修改。它支持 FATl2、 FATl6 和 FAT32，支持多个存储媒介；有独立的缓冲区，可以对多个文件进行读／写，并特别对 8 位单片机和 16 位单片机做了优化。</p><h3 id="_2-它有什么特点" tabindex="-1">2. 它有什么特点 <a class="header-anchor" href="#_2-它有什么特点" aria-label="Permalink to &quot;2. 它有什么特点&quot;">​</a></h3><p>（1）Windows 兼容的 FAT 文件系统（支持 FAT12/FAT16/FAT32）</p><p>（2）与平台无关，移植简单</p><p>（3）代码量少、效率高</p><p>（4）多种配置选项。例如，支持多卷（物理驱动器或分区，最多 10 个卷）；多个 ANSI/OEM 代码页包括 DBCS；支持长文件名、 ANSI/OEM 或 Unicode；支持 RTOS；支持多种扇区大小；只读、最小化的 API 和 I/O 缓冲区等</p><p>FATFS 的这些特点，加上免费、开源的原则，使得 FATFS 应用非常广泛。</p><h3 id="_3-官网与资料" tabindex="-1">3. 官网与资料 <a class="header-anchor" href="#_3-官网与资料" aria-label="Permalink to &quot;3. 官网与资料&quot;">​</a></h3><p>我们可以在这里找到FatFs文件系统的参考文档以及文件系统的压缩包：<a href="http://elm-chan.org/fsw/ff/00index_e.html" target="_blank" rel="noreferrer">FatFs - Generic FAT Filesystem Module (elm-chan.org)</a></p><img src="'+e+'" alt="image-20230513214818295" style="zoom:50%;"><p>我们下载最新版本的FatFs文件系统，并解压，我们会得到如下文件：</p><img src="'+t+'" alt="image-20230513215401849" style="zoom:80%;"><ul><li><p>documents目录下是一些帮助文档，里面是编译好的 html 文档，讲的是 FATFS 里面各个函数的使用方法，这些函数都是封装得非常好的函数，利用这些函数我们就可以操作 SPI Flash 芯片。</p></li><li><p>source目录下是FatFs文件系统的源码。</p></li></ul><p>（1）diskio.c 文件是 FatFs 移植最关键的文件，它为文件系统提供了最底层的访问 SPI Flash 芯片以及SD卡的方法， FatFs 有且仅有它需要用到与 SPI Flash 芯片和SD卡相关的函数。</p><p>（2）diskio.h 定义了 FatFs 用到的宏，以及 diskio.c 文件内与底层硬件接口相关的函数声明。</p><p>（3）00history.txt 介绍了 FatFs 的版本更新情况。</p><p>（4）00readme.txt 说明了当前目录下 ff.c、ffconf.h、ff.h、diskio.h、diskio.c、ffunicode.c、ffsystem.c等文件的功能。</p><h3 id="_4-系统结构" tabindex="-1">4. 系统结构 <a class="header-anchor" href="#_4-系统结构" aria-label="Permalink to &quot;4. 系统结构&quot;">​</a></h3><p>我们上边看到源码目录中有那么多文件，它们有什么联系呢？这些重要的文件功能如下：</p><table tabindex="0"><thead><tr><th>文件名</th><th>说明</th></tr></thead><tbody><tr><td>diskio.c</td><td>FATFS和disk I/O模块接口层源文件，在这里实现对存储介质的初始化和读写操作。</td></tr><tr><td>diskio.h</td><td>FATFS和disk I/O模块接口层头文件，包括函数声明和一些返回值的定义。</td></tr><tr><td>ff.c</td><td>FatFs 核心文件，文件管理的实现方法。该文件独立于底层介质操作文件的函数，利用这些函数实现文件的读写。如f_open等 。</td></tr><tr><td>ff.h</td><td>FATFS和应用模块公用的包含文件，包括函数声明、一些数据类型的定义和重命名，都在这里。。</td></tr><tr><td>ffsystem.c</td><td>用户为fatf提供操作系统相关函数的示例代码，我感觉这像是给操作系统用的，里边有一些锁的函数实现，这里边的函数声明在ff.h中。</td></tr><tr><td>ffunicode.c</td><td>编码的一些格式，包含了简体中文的GBK 和 Unicode 相互转换功能函数。</td></tr><tr><td>ffconf.h</td><td>FatFs模块配置文件。这个头文件包含了对 FatFs 功能配置的宏定义，通过修改这些宏定义就可以裁剪FatFs 的功能。</td></tr></tbody></table><p>它们之间的关系网络如下图：</p><img src="'+p+`" alt="image-20230514073151016" style="zoom:50%;"><p>（1）用户应用程序：我们实际用来实现功能的部分，比如说我们要打开文件，就f_open()，关闭文件就用f_close()，读写文件就用f_read()和f_write()等。</p><p>（2）FatFs组件，这就是我们使用的FatFs文件系统，我们在应用程序使用f_open()这些函数在哪实现的？就是在ff.c、ffsystem.c中实现，在ff.h中声明，由用户调用，像一些读写的功能，我们其实是可以配置的，比如设置成只读，那么写的操作就会被屏蔽，这就是通过ffconf.h中的预编译宏来进行配置，选中的才会被编译到最终的可执行文件。那么f_read()、f_write()这些函数怎么去操作存储介质，完成存储和读取的？这个时候就来到了diskio.c和diskio.h中，这两个文件中实现存储介质的初始化和读写等相关功能。</p><p>（3）底层设备输入输出：这一部分就是实际对存储介质的操作了，比如SPI FLASH或者SD卡的初始化，读和写操作等，这里完成相关功能由diskio.c调用，实现对底层的操作，这一层是直接操作底层硬件设备的。</p><p>（4）物理设备：这一层自然就是我们的物理存储设备了，比如SPI FLASH、SD卡或者EEPROM等。</p><h2 id="三、fatfs重要文件" tabindex="-1">三、FatFs重要文件 <a class="header-anchor" href="#三、fatfs重要文件" aria-label="Permalink to &quot;三、FatFs重要文件&quot;">​</a></h2><p>接下来我们来了解几个文件，看依稀文件中有哪些重要的内容，方便后边移植。</p><h3 id="_1-ffconf-h" tabindex="-1">1. ffconf.h <a class="header-anchor" href="#_1-ffconf-h" aria-label="Permalink to &quot;1. ffconf.h&quot;">​</a></h3><p>我们先来看一下配置文件，里边定义了大量的宏，我们来看一些重要的。</p><h4 id="_1-1-ff-fs-readonly" tabindex="-1">1.1 FF_FS_READONLY <a class="header-anchor" href="#_1-1-ff-fs-readonly" aria-label="Permalink to &quot;1.1 FF_FS_READONLY&quot;">​</a></h4><div class="language-c vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#define</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> FF_FS_READONLY</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">	0</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>该选项切换只读配置。(0：读写或1：只读)，只读配置将会删除写相关的API函数，例如f_write()， f_sync()， f_unlink()， f_mkdir()， f_chmod()， f_rename()， f_truncate()， f_getfree()以及一些可选的写函数。</p><h4 id="_1-2-ff-use-mkfs" tabindex="-1">1.2 FF_USE_MKFS <a class="header-anchor" href="#_1-2-ff-use-mkfs" aria-label="Permalink to &quot;1.2 FF_USE_MKFS&quot;">​</a></h4><div class="language-c vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#define</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> FF_USE_MKFS</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">		0</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>这个宏，选择是否启用 f_mkfs() 函数，这个函数是用来创建文件系统的，应该是会格式化原有的文件系统。</p><h4 id="_1-3-ff-volumes" tabindex="-1">1.3 FF_VOLUMES <a class="header-anchor" href="#_1-3-ff-volumes" aria-label="Permalink to &quot;1.3 FF_VOLUMES&quot;">​</a></h4><div class="language-c vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#define</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> FF_VOLUMES</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">		1</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>这个就比较重要了，它是用来设置我们的这个文件系统支持多少个存储介质，也就是要使用的卷(逻辑驱动器)的数量。范围是1~10，比如说我们现在有两个存储介质，SPI FLASH和SD卡，我们可能需要两个都使用，这样的话，我们这个宏就需要大于2，不然有一个是无法操作的。</p><h4 id="_1-4-ff-xxx-ss" tabindex="-1">1.4 FF_XXX_SS <a class="header-anchor" href="#_1-4-ff-xxx-ss" aria-label="Permalink to &quot;1.4 FF_XXX_SS&quot;">​</a></h4><div class="language-c vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#define</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> FF_MIN_SS</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">		512</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#define</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> FF_MAX_SS</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">		512</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>指定扇区大小的最小值和最大值。 SD 卡扇区大小一般都为 512 字节， SPI Flash 芯片扇区大小一般设置为 4096 字节，所以若是使用的时候需要把 FF_MAX_SS 改为 4096。</p><p>注意：这里我们使用的存储设备的扇区大小非512，需要修改时，FF_MAX_SS与FF_MIN_SS不相等的时候，我们需要在后边实现disk_ioctl函数，在这个函数中获取不同设备扇区大小，否则可能会报 The physical drive cannot work这一类错误。</p><h3 id="_2-diskio-c" tabindex="-1">2. diskio.c <a class="header-anchor" href="#_2-diskio-c" aria-label="Permalink to &quot;2. diskio.c&quot;">​</a></h3><h4 id="_2-1-disk-status" tabindex="-1">2.1 disk_status() <a class="header-anchor" href="#_2-1-disk-status" aria-label="Permalink to &quot;2.1 disk_status()&quot;">​</a></h4><div class="language-c vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">DSTATUS </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">disk_status</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	BYTE pdrv</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">		/* Physical drive nmuber to identify the drive */</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>**【函数说明】**这个函数主要是获取存储设备的状态，根据定义的逻辑驱动器号来选择获取不同的设备的状态，这个状态的获取需要我们在对应的存储设备驱动文件中实现，并在这里调用。</p><img src="`+h+`" alt="image-20230514080259689" style="zoom:50%;"><p><strong>【参数说明】</strong></p><ul><li>pdrv ：BYTE类型，逻辑驱动器的编号。</li></ul><h4 id="_2-2-disk-initialize" tabindex="-1">2.2 disk_initialize() <a class="header-anchor" href="#_2-2-disk-initialize" aria-label="Permalink to &quot;2.2 disk_initialize()&quot;">​</a></h4><div class="language-c vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">DSTATUS </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">disk_initialize</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	BYTE pdrv</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">				/* Physical drive nmuber to identify the drive */</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>**【函数说明】**这个函数主要是初始化存储设备，需要我们自己实现对应的初始化函数，并在这里调用。</p><img src="`+k+`" alt="image-20230514080246220" style="zoom:50%;"><p><strong>【参数说明】</strong></p><ul><li>pdrv ：BYTE类型，逻辑驱动器的编号。</li></ul><h4 id="_2-3-disk-read" tabindex="-1">2.3 disk_read() <a class="header-anchor" href="#_2-3-disk-read" aria-label="Permalink to &quot;2.3 disk_read()&quot;">​</a></h4><div class="language-c vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">DRESULT </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">disk_read</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	BYTE </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">pdrv</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">		/* Physical drive nmuber to identify the drive */</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	BYTE </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">buff</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">		/* Data buffer to store read data */</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">	LBA_t</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> sector</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">	/* Start sector in LBA */</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	UINT count</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">		/* Number of sectors to read */</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>**【函数说明】**这个函数主要是从存储设备读取数据，需要我们自己实现对应的初始化函数，并在这里调用。</p><img src="`+r+`" alt="image-20230514080320055" style="zoom:50%;"><p><strong>【参数说明】</strong></p><ul><li>pdrv ：BYTE类型，逻辑驱动器的编号。</li><li>buff ：BYTE *类型，表示读取的数据将要存放的位置，需要传入一个地址用于存储读取的数据。</li><li>sector ：LBA_t类型，表示要读取哪一个扇区。</li><li>count ：UINT类型，表示要读取的扇区数量。</li></ul><h4 id="_2-4-disk-write" tabindex="-1">2.4 disk_write() <a class="header-anchor" href="#_2-4-disk-write" aria-label="Permalink to &quot;2.4 disk_write()&quot;">​</a></h4><div class="language-c vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">DRESULT </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">disk_write</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	BYTE </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">pdrv</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">			/* Physical drive nmuber to identify the drive */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> BYTE </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">buff</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">	/* Data to be written */</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">	LBA_t</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> sector</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">		/* Start sector in LBA */</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	UINT count</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">			/* Number of sectors to write */</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>**【函数说明】**这个函数主要是向存储设备写入数据，需要我们自己实现对应的初始化函数，并在这里调用。</p><img src="`+d+`" alt="image-20230514080329214" style="zoom:50%;"><p><strong>【参数说明】</strong></p><ul><li>pdrv ：BYTE类型，逻辑驱动器的编号。</li><li>buff ：BYTE *类型，表示要写入的数据存放的位置，需要传入一个地址用于存储将要写入的数据。</li><li>sector ：LBA_t类型，表示要写入到哪一个扇区。</li><li>count ：UINT类型，表示要写入的扇区数量。</li></ul><h4 id="_2-5-disk-ioctl" tabindex="-1">2.5 disk_ioctl() <a class="header-anchor" href="#_2-5-disk-ioctl" aria-label="Permalink to &quot;2.5 disk_ioctl()&quot;">​</a></h4><div class="language-c vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">DRESULT </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">disk_ioctl</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	BYTE </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">pdrv</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">		/* Physical drive nmuber (0..) */</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	BYTE </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">cmd</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">		/* Control code */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	void</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">buff</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">		/* Buffer to send/receive control data */</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>**【函数说明】**这个函数主要是对设备执行一些自定义的命令，比如读取设备信息等，具体要实现什么功能需要自己定义，并且实现，然后在这里调用。</p><img src="`+E+`" alt="image-20230514080340682" style="zoom:50%;"><p><strong>【参数说明】</strong></p><ul><li>pdrv ：BYTE类型，逻辑驱动器的编号。</li><li>cmd ：BYTE类型，表示要执行的命令类型，根据不同的命令实现不同的功能。</li><li>buff ：void *类型，表示一个缓冲区的地址，存放数据，看自己的需求了。</li></ul><p>**【注意事项】**注意我们在这里读写的时候最好实现获取存储设备块大小的相关命令，块的大小在读写的时候会用到，不实现的话会有很多坑。</p><h4 id="_2-6-get-fattime" tabindex="-1">2.6 get_fattime() <a class="header-anchor" href="#_2-6-get-fattime" aria-label="Permalink to &quot;2.6 get_fattime()&quot;">​</a></h4><div class="language-c vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">DWORD </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">get_fattime</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>**【函数说明】**这个函数主要是获取当前的时间。</p><img src="`+c+`" alt="image-20230514080618616" style="zoom:50%;"><p>**【参数说明】**none</p><p>**【注意事项】**这个函数在新版本的FatFs中没有实现，但是会有调用，所以这个我们需要自己实现一下，可以什么都不做，但是要有。</p><h3 id="_3-ff-c" tabindex="-1">3. ff.c <a class="header-anchor" href="#_3-ff-c" aria-label="Permalink to &quot;3. ff.c&quot;">​</a></h3><p>这里主要是一些应用层的函数，这里就不详细说了，详细的可以查看官网说明文档：<a href="http://elm-chan.org/fsw/ff/00index_e.html" target="_blank" rel="noreferrer">FatFs - Generic FAT Filesystem Module (elm-chan.org)</a>的Application Interface，这些文档其实在我们下载的FatFs包中有本地的，也可以看。</p><div class="language-c vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">f_mount </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 注册</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">/</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">注销一个工作区域（Work Area）</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">f_open </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 打开</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">/</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">创建一个文件</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">f_close </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 关闭一个文件</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">f_read </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 读文件</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">f_write </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 写文件</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">f_lseek </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 移动文件读</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">/</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">写指针</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">f_truncate </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">截断文件</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">f_sync </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  冲洗缓冲数据 Flush Cached Data</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">f_forward </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 直接转移文件数据到一个数据流</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">f_stat </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 获取文件状态</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">f_opendir </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 打开一个目录 </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">f_closedir </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">关闭一个已经打开的目录</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">f_readdir </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 读取目录条目</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">f_mkdir </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 创建一个目录</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">f_unlink </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">删除一个文件或目录</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">f_chmod </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  改变属性（Attribute）</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">f_utime </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">改变时间戳（Timestamp）</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">f_rename </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 重命名</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">/</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">移动一个文件或文件夹</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">f_chdir </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 改变当前目录</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">f_chdrive </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 改变当前驱动器</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">f_getcwd </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  获取当前工作目录 </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">f_getfree </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 获取空闲簇 Get Free Clusters</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">f_getlabel </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Get volume label</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">f_setlabel </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Set volume label</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">f_mkfs </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 在驱动器上创建一个文件系统</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">f_fdisk </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Divide a physical drive</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">f_gets </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 读一个字符串</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">f_putc </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 写一个字符</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">f_puts </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 写一个字符串</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">f_printf </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 写一个格式化的字符串</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">f_tell </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 获取当前读</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">/</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">写指针</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">f_eof </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 测试文件结束</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">f_size </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 获取文件大小</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">f_error </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 测试文件上的错误</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br></div></div><h2 id="四、api与返回值" tabindex="-1">四、API与返回值 <a class="header-anchor" href="#四、api与返回值" aria-label="Permalink to &quot;四、API与返回值&quot;">​</a></h2><p>我们来看几个函数，以及结构体，方便后边测试和配置的时候使用。</p><h3 id="_1-两个结构体" tabindex="-1">1. 两个结构体 <a class="header-anchor" href="#_1-两个结构体" aria-label="Permalink to &quot;1. 两个结构体&quot;">​</a></h3><h4 id="_1-1-fatfs" tabindex="-1">1.1 FATFS <a class="header-anchor" href="#_1-1-fatfs" aria-label="Permalink to &quot;1.1 FATFS&quot;">​</a></h4><p>关于该结构体，它定义在ff.h文件中，我们可以参考官方文档：<a href="http://elm-chan.org/fsw/ff/doc/sfatfs.html" target="_blank" rel="noreferrer">FatFs - FATFS (elm-chan.org)</a></p><div class="language-c vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/* Filesystem object structure (FATFS) */</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">typedef</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	BYTE	fs_type;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">		/* Filesystem type (0:not mounted) */</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	BYTE	pdrv;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">			/* Volume hosting physical drive */</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	BYTE	ldrv;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">			/* Logical drive number (used only when FF_FS_REENTRANT) */</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	BYTE	n_fats;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">			/* Number of FATs (1 or 2) */</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">	// 中间的部分省略</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	BYTE	</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">win</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[FF_MAX_SS];</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">	/* Disk access window for Directory, FAT (and file data at tiny cfg) */</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">} FATFS;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>FATFS结构(文件系统对象)保存各个逻辑驱动器的动态工作区域。它由应用程序给出，并通过f_mount函数注册/取消注册到FatFs模块。结构的初始化在必要时由卷挂载进程完成。应用程序不得修改此结构中的任何成员，否则将导致FAT卷崩溃。</p><p>我们要注意一下这个结构体是非常大的，我们可以看到最后一个成员win，这是一个数组，大小为FF_MAX_SS，这个最大值我们后边可能会配置为4096，这样下来这个结构体就非常的大，用它定义的变量最好不要定义为局部变量，否则可能会导致栈的溢出，当然，要是我们的栈非常大的话吗，就可以不用考虑这个问题了。</p><h4 id="_1-2-fil" tabindex="-1">1.2 FIL <a class="header-anchor" href="#_1-2-fil" aria-label="Permalink to &quot;1.2 FIL&quot;">​</a></h4><p>关于该结构体，它定义在ff.h中，我们可以参考官方文档：<a href="http://elm-chan.org/fsw/ff/doc/sfile.html" target="_blank" rel="noreferrer">FatFs - FIL (elm-chan.org)</a></p><div class="language-c vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/* File object structure (FIL) */</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">typedef</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	FFOBJID	obj;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">			/* Object identifier (must be the 1st member to detect invalid object pointer) */</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	BYTE	flag;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">			/* File status flags */</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	BYTE	err;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">			/* Abort flag (error code) */</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">	FSIZE_t</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	fptr;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">			/* File read/write pointer (Zeroed on file open) */</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	DWORD	clust;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">			/* Current cluster of fpter (invalid when fptr is 0) */</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">	LBA_t</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	sect;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">			/* Sector number appearing in buf[] (0:invalid) */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#if</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> !</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">FF_FS_READONLY</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">	LBA_t</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	dir_sect;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">		/* Sector number containing the directory entry (not used at exFAT) */</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	BYTE</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	dir_ptr;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">		/* Pointer to the directory entry in the win[] (not used at exFAT) */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#endif</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#if</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> FF_USE_FASTSEEK</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	DWORD</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	cltbl;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">			/* Pointer to the cluster link map table (nulled on open, set by application) */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#endif</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#if</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> !</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">FF_FS_TINY</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	BYTE	</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">buf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[FF_MAX_SS];</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">	/* File private data read/write window */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#endif</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">} FIL;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div></div><p>FIL结构(文件对象)保存打开文件的状态。它由f_open函数创建，并由f_close函数丢弃。应用程序不能修改该结构中除cltbl之外的任何成员，否则将导致FAT卷崩溃。请注意，扇区缓冲区是在非微小配置(FF_FS_TINY == 0)的结构中定义的，因此该配置中的FIL结构不应该被定义为自动变量。</p><p>我们要注意一下这个结构体是非常大的，我们可以看到最后一个成员buf，这是一个数组，大小为FF_MAX_SS，这个最大值我们后边可能会配置为4096，这样下来这个结构体跟FATFS一样，就非常的大，所以一般我们也不会将其定义为局部变量。</p><h3 id="_2-函数返回值" tabindex="-1">2. 函数返回值 <a class="header-anchor" href="#_2-函数返回值" aria-label="Permalink to &quot;2. 函数返回值&quot;">​</a></h3><h4 id="_2-1-返回值的枚举类型" tabindex="-1">2.1 返回值的枚举类型 <a class="header-anchor" href="#_2-1-返回值的枚举类型" aria-label="Permalink to &quot;2.1 返回值的枚举类型&quot;">​</a></h4><p>我们首先来了解一下我们常用的一些函数的返回值的含义，我们可以通过这些返回值来判断是哪里出错了：</p><div class="language-c vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/* File function return code (FRESULT) */</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">typedef</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> enum</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	FR_OK </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">				/* (0) Succeeded */</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	FR_DISK_ERR,</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">			/* (1) A hard error occurred in the low level disk I/O layer */</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	FR_INT_ERR,</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">				/* (2) Assertion failed */</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	FR_NOT_READY,</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">			/* (3) The physical drive cannot work */</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	FR_NO_FILE,</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">				/* (4) Could not find the file */</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	FR_NO_PATH,</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">				/* (5) Could not find the path */</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	FR_INVALID_NAME,</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">		/* (6) The path name format is invalid */</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	FR_DENIED,</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">				/* (7) Access denied due to prohibited access or directory full */</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	FR_EXIST,</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">				/* (8) Access denied due to prohibited access */</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	FR_INVALID_OBJECT,</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">		/* (9) The file/directory object is invalid */</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	FR_WRITE_PROTECTED,</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">		/* (10) The physical drive is write protected */</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	FR_INVALID_DRIVE,</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">		/* (11) The logical drive number is invalid */</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	FR_NOT_ENABLED,</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">			/* (12) The volume has no work area */</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	FR_NO_FILESYSTEM,</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">		/* (13) There is no valid FAT volume */</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	FR_MKFS_ABORTED,</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">		/* (14) The f_mkfs() aborted due to any problem */</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	FR_TIMEOUT,</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">				/* (15) Could not get a grant to access the volume within defined period */</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	FR_LOCKED,</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">				/* (16) The operation is rejected according to the file sharing policy */</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	FR_NOT_ENOUGH_CORE,</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">		/* (17) LFN working buffer could not be allocated */</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	FR_TOO_MANY_OPEN_FILES,</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">	/* (18) Number of open files &gt; FF_FS_LOCK */</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	FR_INVALID_PARAMETER</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">	/* (19) Given parameter is invalid */</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">} FRESULT;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br></div></div><p>这是一个枚举类型，它也定义在ff.h中，我们可以参考官方文档来详细了解这些值的含义：<a href="http://elm-chan.org/fsw/ff/doc/rc.html#id" target="_blank" rel="noreferrer">FatFs - API Return Code (elm-chan.org)</a></p><h4 id="_2-2-字符串数组" tabindex="-1">2.2 字符串数组？ <a class="header-anchor" href="#_2-2-字符串数组" aria-label="Permalink to &quot;2.2 字符串数组？&quot;">​</a></h4><p>上边返回值好多，我们知道值的话，还需要知道代表什么含义，我们其实可以定义一个二维数组，按顺序将上边的枚举所代表的含义依次写入，然后打印的时候就可以直接获取错误码的含义了，不过这样可能会比较占内存，慎用。</p><div class="language-c vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">static</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> BYTE API_RET</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">[]</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">90</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    &quot;(0) Succeeded &quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    &quot;(1) A hard error occurred in the low level disk I/O layer &quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    &quot;(2) Assertion failed &quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    &quot;(3) The physical drive cannot work &quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    &quot;(4) Could not find the file &quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    &quot;(5) Could not find the path &quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    &quot;(6) The path name format is invalid &quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    &quot;(7) Access denied due to prohibited access or directory full &quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    &quot;(8) Access denied due to prohibited access &quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    &quot;(9) The file/directory object is invalid &quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    &quot;(10) The physical drive is write protected &quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    &quot;(11) The logical drive number is invalid &quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    &quot;(12) The volume has no work area &quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    &quot;(13) There is no valid FAT volume &quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    &quot;(14) The f_mkfs() aborted due to any problem &quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    &quot;(15) Could not get a grant to access the volume within defined period &quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    &quot;(16) The operation is rejected according to the file sharing policy &quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    &quot;(17) LFN working buffer could not be allocated &quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    &quot;(18) Number of open files &gt; FF_FS_LOCK &quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    &quot;(19) Given parameter is invalid &quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br></div></div><p>我们打印的时候就可以这样：</p><div class="language-c vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">printf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;res:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">%s\\n\\r</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">API_RET</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[res]);</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>这样就可以直接将错误的原因打印出来啦。</p><h3 id="_3-常用函数" tabindex="-1">3. 常用函数 <a class="header-anchor" href="#_3-常用函数" aria-label="Permalink to &quot;3. 常用函数&quot;">​</a></h3><h4 id="_3-1-f-mount" tabindex="-1">3.1 f_mount() <a class="header-anchor" href="#_3-1-f-mount" aria-label="Permalink to &quot;3.1 f_mount()&quot;">​</a></h4><p>我们可以参考<a href="http://elm-chan.org/fsw/ff/doc/mount.html" target="_blank" rel="noreferrer">FatFs - f_mount (elm-chan.org)</a>：</p><div class="language-c vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">FRESULT </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">f_mount</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  FATFS</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">       fs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    /* [IN] Filesystem object */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> TCHAR</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> path</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  /* [IN] Logical drive number */</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  BYTE         opt</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    /* [IN] Initialization option */</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>**【函数说明】**f_mount函数为FatFs模块提供工作区域。也就是用于挂载我们存储设备上的文件系统，挂载之后我们才能正常的使用这个文件系统。</p><p><strong>【函数参数】</strong></p><ul><li>fs ：指向要注册和清除的文件系统对象的指针。若是NULL的话，则表示取消注册已注册的文件系统对象，每个存储介质只需要一个即可，用于存储这个存储设备的文件系统的信息。</li><li>path ：指向指定逻辑驱动器的以空结尾的字符串的指针。不带驱动器号的字符串为默认驱动器。比如我们上边规定的SPI FLASH的drive number为1，那么这里就可以写 “1:” ，当挂载成功后，他就相当于我们win中的C、D等这些的盘符。</li><li>opt ：0，现在不挂载(要在第一次访问卷时挂载)，1，强制立即挂载卷，并检查卷是否可以工作。</li></ul><h4 id="_3-2-f-mkfs" tabindex="-1">3.2 f_mkfs() <a class="header-anchor" href="#_3-2-f-mkfs" aria-label="Permalink to &quot;3.2 f_mkfs()&quot;">​</a></h4><p>我们可以参考<a href="http://elm-chan.org/fsw/ff/doc/mkfs.html" target="_blank" rel="noreferrer">FatFs - f_mkfs (elm-chan.org)</a>:</p><div class="language-c vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">FRESULT </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">f_mkfs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> TCHAR</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> path</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   /* [IN] Logical drive number */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> MKFS_PARM</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> opt</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/* [IN] Format options */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  void*</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> work</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">          /* [-]  Working buffer */</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  UINT len</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">             /* [IN] Size of working buffer */</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>**【函数说明】**f_mkfs函数在逻辑驱动器上创建一个FAT/exFAT卷。什么意思呢？就是我们的存储介质上原本是什么都没有的，我们需要将其格式化并创建一个文件系统，这样我们才能正常的去使用文件系统来管理其中的文件。</p><p><strong>【函数参数】</strong></p><ul><li><p>path：指向以空结尾的字符串的指针指定要格式化的逻辑驱动器。如果其中没有驱动器号，则表示指定默认驱动器。在格式化过程中，逻辑驱动器可能已经挂载，也可能没有挂载。</p></li><li><p>opt ：MKFS_PARM 类型结构体指针变量，表示格式选项。如果给出一个空指针，它将给函数提供默认值中的每个选项，详细情况我们可以看一下参考文档中的详细说明。</p></li><li><p>work ：指向格式化过程使用的工作缓冲区的指针。如果 null 指针以 FF_USE_LFN == 3 给出，则该函数在此函数中使用 len 字节的堆内存。</p></li><li><p>len ：工作缓冲区的大小，以字节为单位。它至少需要是FF_MAX_SS。大量的工作缓冲区减少了对驱动器的写事务数量，因此格式化过程将很快完成。</p></li></ul><h3 id="_4-时间函数get-fattime" tabindex="-1">4. 时间函数get_fattime() <a class="header-anchor" href="#_4-时间函数get-fattime" aria-label="Permalink to &quot;4. 时间函数get_fattime()&quot;">​</a></h3><p>这个函数是所有存储介质移植的时候都需要的，这个函数在FatFs源码中没有定义，但是又用到了，所以还是需要定义一下的，不然会报错。我们可以看一下参考文档<a href="http://elm-chan.org/fsw/ff/doc/fattime.html" target="_blank" rel="noreferrer">FatFs - get_fattime (elm-chan.org)</a>，函数声明如下：</p><div class="language-c vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">DWORD </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">get_fattime</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>这个函数主要是获取当前的时间，这个函数在FatFs系统中没有实现，我们直接编译是会报这个错误的，我们可以通过STM32的RTC来获取时间，当然，若是暂时不需要，我们可以将其定义为如下的形式：</p><div class="language-c vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/**</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  * </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">@brief</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  获取当前系统时间</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  * </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">@note</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   用于文件时间属性的确定</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  * </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">@param</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  * </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">@retval</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  */</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">DWORD </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">get_fattime</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">	/* 返回当前时间戳 */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ((DWORD)(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2015</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> -</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1980</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 25</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> /* Year 2015 */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">		   |</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ((DWORD)</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &lt;&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 21</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">			/* Month 1 */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">		   |</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ((DWORD)</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &lt;&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 16</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">			/* Mday 1 */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">		   |</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ((DWORD)</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &lt;&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 11</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">			/* Hour 0 */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">		   |</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ((DWORD)</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &lt;&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">			/* Min 0 */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">		   |</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ((DWORD)</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &gt;&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">			/* Sec 0 */</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><h2 id="五、移植说明" tabindex="-1">五、移植说明 <a class="header-anchor" href="#五、移植说明" aria-label="Permalink to &quot;五、移植说明&quot;">​</a></h2><p>FatFs 文件系统与底层介质的驱动分离开来，对底层介质的操作都要交给用户去实现，它仅仅是提供了一个函数接口而已，下表是为 FatFs 移植时用户必须支持的函数（新版本的FatFs系统在函数命名或者宏的命名或者文件名可能于下表有一些出入，但是大概都是一个意思）：</p><img src="`+o+'" alt="image-20230602190402837" style="zoom:50%;"><p>FatFs 移植需要用户支持函数我们可以清晰知道很多函数是在一定条件下才需要添加的，只有前三个函数是必须添加的。我们完全可以根据实际需求选择实现用到的函数。</p><p>前三个函数是实现读文件最基本需求。接下来三个函数是实现创建文件、修改文件需要的。为实现格式化功能，需要在 disk_ioctl 添加两个获取物理设备信息选项。我们一般只要实现前面六个函数就可以了，已经足够满足大部分功能。</p><p>为支持简体中文长文件名称需要添加 ff_convert 和 ff_wtoupper 函数，实际这两个已经在 cc936.c文件中实现，我们只要直接把 cc936.c 文件添加到工程中就可以。后面六个函数一般都不用。</p>',135)])])}const _=i(g,[["render",b]]);export{D as __pageData,_ as default};
